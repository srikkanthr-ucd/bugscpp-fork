# A Python API Interface to provide additional functions for querying LLMs in our RQ2 study
# Author: Xinzhuo (Johnson) Hu
# Create Date: 2024-03-14 14:31 pm

import os
import re
import csv
import tiktoken
from datetime import datetime
import dataset_api


# Here we use gpt3.5-turbo model to approximate the tokenization process
def num_tokens_from_string(string: str, encoding_name = 'cl100k_base') -> int:
    encoding = tiktoken.get_encoding(encoding_name)
    num_tokens = len(encoding.encode(string))
    return num_tokens

# Obtain original Test Failure Information
def getOriginalTestFailureInfo(buggy_repo_name : str):
    result = dataset_api.test_default_buggy_codes_with_failed_tcs(buggy_repo_name)
    fail_test_cases_info = result.test_cases_result.fail_test_cases_info
    fail_key = list(fail_test_cases_info.keys())[0]
    test_fail_info_str = fail_test_cases_info[fail_key]["failing_info"]
    test_fail_code_str = fail_test_cases_info[fail_key]["tc_code"]

    return test_fail_info_str, test_fail_code_str


def formatLLMResponse(prompt: str) -> str:
     format_message = (
    f"""You will only respond with your repaired function in a code snippet as below:
```
<Your repaired function>
```
"""
    )
     # format_message = "You will only respond with your repaired function."
     prompt += '\n' + format_message
     return prompt 

# Construct Initial Prompt contains the buggy function and its test failure information
def constructRQ2InitialPrompt(buggy_function : str, test_fail_str : str, test_code_str : str) -> str:
    user_message = (
    f"""You are a automated program repair tool for C and C++. Your task is to provide a fix for the buggy function below.

<<< Buggy Function:
{buggy_function}
>>>
"""
    )

    test_fail_message = (
    f"""The following was the errors outputted by a failed test case.

<<< Test Failed Log:
{test_fail_str}
>>>
"""
    )

    test_code_message = (
    f"""The following is the relevant code of that failed test case.

<<< Test Code:
{test_code_str}
>>>
"""
    )

    prompt_message = user_message
    if test_fail_str: prompt_message += '\n' + test_fail_message
    if test_code_str: prompt_message += '\n' + test_code_message

    return prompt_message

def constructRQ2CompileFailPrompt(initialPrompt : str, llm_patch : str, compile_failure_info : str) -> str:
    user_message = (
    f"""The function provided by you is still not correct! Your repaired function is:

<<< Function Repaired By You:
{llm_patch}
>>>
"""
    )

    compile_message = (
    f"""That function has the following compiliation error:

<<< Compliation Error:
{compile_failure_info}
>>>
"""
    )

    prompt_message = initialPrompt
    if llm_patch: prompt_message += '\n' + user_message
    if compile_failure_info: prompt_message += '\n' + compile_message

    return prompt_message

def constructRQ2OriTestFailPrompt(initialPrompt : str, llm_patch : str) -> str:
    user_message = (
    f"""The function provided by you is still not correct! Your repaired function is:

<<< Function Repaired By You:
{llm_patch}
>>>

It still does not fix the original test failure stated above!
"""
    )

    prompt_message = initialPrompt
    if llm_patch: prompt_message += '\n' + user_message

    return prompt_message

def constructRQ2PlausiblePrompt(initialPrompt : str, plausible_patch_str_list : list) -> str:
    # form the plausible patch list to be a whole string
    whole_plausible_patches_str = "\n\n".join(plausible_patch_str_list)

    user_message = (
    f"""The functions provided by you can pass all test cases:

<<< Plausible Patches Generated By You:
{whole_plausible_patches_str}
>>>

Please generate an alternative fix function.
"""
    )

    prompt_message = initialPrompt
    prompt_message += '\n' + user_message

    return prompt_message

# Input: a base-directory
# Input: a 2-level list return by run_exps_from_buggyrepolist
# Output: a successful message
def saveRQ2RepoAvgStatCSV(output_dir: str, repo_stat_list: list):

    now = datetime.now()
    timestamp_str = now.strftime("%m%d%Y_%H%M%S")
    filename = "repo_stat_ConversationRepair" + "_" + timestamp_str + ".csv"
    # field names
    fields = ['Test_Repo', 'Conversation_Num', 'Total_Patch_Num', 'Compilable_Patch_Num', 'Plausible_Patch_Num', 'Average_Response_Time']
    
    # Check num of field names in input repo_stat_list
    if len(repo_stat_list[0]) != 6: raise RuntimeError("Input Repo List Field Number Mismatch!")

    # writing to csv file
    with open(os.path.join(output_dir, filename), 'w') as csvfile:
        csvwriter = csv.writer(csvfile)
        # writing the fields
        csvwriter.writerow(fields)
        # writing the data rows
        csvwriter.writerows(repo_stat_list)
    # successful message
    print(f"  Success: write {filename} into {output_dir} .")


# Input: a base directory, the Input Prompt
# Output: a successful message:
def saveInputPromptTXT(output_dir : str, input_prompt : str):
    os.makedirs(output_dir, exist_ok=True)
    filename = 'input_prompt.txt'
    f = open(os.path.join(output_dir, filename), "w")
    f.write(input_prompt)
    f.close()

    # successful message
    print(f"  Success: write {filename} into {output_dir} .")