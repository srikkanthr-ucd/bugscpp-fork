{
    "libtiff-1": {
      "buggy_file": "tiffcrop.c",
      "buggy_function": "static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      for (s = 0; s < spp; s++)\n        {  /* Read each plane of a tile set into srcbuffs[s] */\n\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n        if (tbytes < 0  && !ignore)\n          {\n\t  TIFFError(TIFFFileName(in),\n                 \"Error, can't read tile for row %lu col %lu, \"\n\t\t \"sample %lu\",\n\t\t (unsigned long) col, (unsigned long) row,\n\t\t (unsigned long) s);\n\t\t status = 0;\n          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n            {\n            tbuff = srcbuffs[sample];\n            if (tbuff != NULL)\n              _TIFFfree(tbuff);\n            }\n          return status;\n\t  }\n\t}\n     /* Tiles on the right edge may be padded out to tw \n      * which must be a multiple of 16.\n      * Ncol represents the visible (non padding) portion.  \n      */\n      if (col + tw > imagewidth)\n        ncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n      col_offset = ((col * spp * bps) + 7) / 8;\n      bufp = obuf + row_offset + col_offset;\n\n      if ((bps % 8) == 0)\n        {\n        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n\t  {\n          status = 0;\n          break;\n      \t  }\n\t}\n      else\n        {\n        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n        if (bytes_per_pixel < (bytes_per_sample + 1))\n          shift_width = bytes_per_pixel;\n        else\n          shift_width = bytes_per_sample + 1;\n\n        switch (shift_width)\n          {\n          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n      \t            }\n\t          break;\n          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n       \t            }\n                  break;\n          case 4: \n          case 5:\n          case 6:\n          case 7:\n          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          default: TIFFError (\"readSeparateTilesIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  status = 0;\n                  break;\n          }\n        }\n      }\n    }\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    tbuff = srcbuffs[sample];\n    if (tbuff != NULL)\n      _TIFFfree(tbuff);\n    }\n \n  return status;\n  }\n",
      "start_index": 950,
      "end_index": 1095,
      "buggy_line_no": [42],
      "buggy_function_with_label": "static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      <start_bug>\n      for (s = 0; s < spp; s++)\n      <end_bug>\n        {  /* Read each plane of a tile set into srcbuffs[s] */\n\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n        if (tbytes < 0  && !ignore)\n          {\n\t  TIFFError(TIFFFileName(in),\n                 \"Error, can't read tile for row %lu col %lu, \"\n\t\t \"sample %lu\",\n\t\t (unsigned long) col, (unsigned long) row,\n\t\t (unsigned long) s);\n\t\t status = 0;\n          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n            {\n            tbuff = srcbuffs[sample];\n            if (tbuff != NULL)\n              _TIFFfree(tbuff);\n            }\n          return status;\n\t  }\n\t}\n     /* Tiles on the right edge may be padded out to tw \n      * which must be a multiple of 16.\n      * Ncol represents the visible (non padding) portion.  \n      */\n      if (col + tw > imagewidth)\n        ncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n      col_offset = ((col * spp * bps) + 7) / 8;\n      bufp = obuf + row_offset + col_offset;\n\n      if ((bps % 8) == 0)\n        {\n        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n\t  {\n          status = 0;\n          break;\n      \t  }\n\t}\n      else\n        {\n        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n        if (bytes_per_pixel < (bytes_per_sample + 1))\n          shift_width = bytes_per_pixel;\n        else\n          shift_width = bytes_per_sample + 1;\n\n        switch (shift_width)\n          {\n          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n      \t            }\n\t          break;\n          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n       \t            }\n                  break;\n          case 4: \n          case 5:\n          case 6:\n          case 7:\n          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          default: TIFFError (\"readSeparateTilesIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  status = 0;\n                  break;\n          }\n        }\n      }\n    }\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    tbuff = srcbuffs[sample];\n    if (tbuff != NULL)\n      _TIFFfree(tbuff);\n    }\n \n  return status;\n  }",
      "buggy_line_with_label_no": [43]
    },
     "libtiff-2": {
      "buggy_file": "gif2tiff.c",
      "buggy_function": "int readextension(void)\n{\n    int count;\n    char buf[255];\n    int status = 1;\n\n    (void) getc(infile);\n    while ((count = getc(infile)) && count <= 255)\n        if (fread(buf, 1, count, infile) != (size_t) count) {\n            fprintf(stderr, \"short read from file %s (%s)\\n\",\n                    filename, strerror(errno));\n            status = 0;\n            break;\n        }\n    return status;\n}\n",
      "start_index": 364,
      "end_index": 380,
      "buggy_line_no": [8],
      "buggy_function_with_label": "int readextension(void)\\n{\\n    int count;\\n    char buf[255];\\n    int status = 1;\\n\\n    (void) getc(infile);\\n<start_bug>\\n    while ((count = getc(infile)) && count <= 255)\\n<end_bug>\\n        if (fread(buf, 1, count, infile) != (size_t) count) {\\n            fprintf(stderr, \"short read from file %s (%s)\\\\n\",\\n                    filename, strerror(errno));\\n            status = 0;\\n            break;\\n        }\\n    return status;\\n}\\n",
      "buggy_line_with_label_no": [9]
    },
     "libtiff-3": {
      "buggy_file": "rgb2ycbcr.c",
      "buggy_function": "int main(int argc, char* argv[])\n  {\n#ifdef DPP_ENABLE_GCOV\n\t  {\n\t\t  dpp_gcov_sigaction.sa_handler = dpp_sighandler;\n\t\t  sigemptyset(&dpp_gcov_sigaction.sa_mask);\n\t\t  dpp_gcov_sigaction.sa_flags = 0;\n\t\t  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t  }\n#endif\n\tTIFF *in, *out;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:h:r:v:z\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (streq(optarg, \"none\"))\n\t\t\t    compression = COMPRESSION_NONE;\n\t\t\telse if (streq(optarg, \"packbits\"))\n\t\t\t    compression = COMPRESSION_PACKBITS;\n\t\t\telse if (streq(optarg, \"lzw\"))\n\t\t\t    compression = COMPRESSION_LZW;\n\t\t\telse if (streq(optarg, \"jpeg\"))\n\t\t\t    compression = COMPRESSION_JPEG;\n\t\t\telse if (streq(optarg, \"zip\"))\n\t\t\t    compression = COMPRESSION_ADOBE_DEFLATE;\n\t\t\telse\n\t\t\t    usage(-1);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thorizSubSampling = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvertSubSampling = atoi(optarg);\n            if( vertSubSampling != 1 && vertSubSampling != 2 && vertSubSampling != 4 )\n                usage(-1);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\t/* CCIR Rec 601-1 w/ headroom/footroom */\n\t\t\trefBlackWhite[0] = 16.;\n\t\t\trefBlackWhite[1] = 235.;\n\t\t\trefBlackWhite[2] = 128.;\n\t\t\trefBlackWhite[3] = 240.;\n\t\t\trefBlackWhite[4] = 128.;\n\t\t\trefBlackWhite[5] = 240.;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage(0);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage(-1);\n\tout = TIFFOpen(argv[argc-1], \"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\tsetupLumaTables();\n\tfor (; optind < argc-1; optind++) {\n\t\tin = TIFFOpen(argv[optind], \"r\");\n\t\tif (in != NULL) {\n\t\t\tdo {\n\t\t\t\tif (!tiffcvt(in, out) ||\n\t\t\t\t    !TIFFWriteDirectory(out)) {\n\t\t\t\t\t(void) TIFFClose(out);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t} while (TIFFReadDirectory(in));\n\t\t\t(void) TIFFClose(in);\n\t\t}\n\t}\n\t(void) TIFFClose(out);\n\treturn (0);\n}\n",
      "start_index": 80,
      "end_index": 160,
      "buggy_line_no": [38],
      "buggy_function_with_label": "int main(int argc, char* argv[])\n  {\n#ifdef DPP_ENABLE_GCOV\n\t  {\n\t\t  dpp_gcov_sigaction.sa_handler = dpp_sighandler;\n\t\t  sigemptyset(&dpp_gcov_sigaction.sa_mask);\n\t\t  dpp_gcov_sigaction.sa_flags = 0;\n\t\t  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t  }\n#endif\n\tTIFF *in, *out;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:h:r:v:z\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (streq(optarg, \"none\"))\n\t\t\t    compression = COMPRESSION_NONE;\n\t\t\telse if (streq(optarg, \"packbits\"))\n\t\t\t    compression = COMPRESSION_PACKBITS;\n\t\t\telse if (streq(optarg, \"lzw\"))\n\t\t\t    compression = COMPRESSION_LZW;\n\t\t\telse if (streq(optarg, \"jpeg\"))\n\t\t\t    compression = COMPRESSION_JPEG;\n\t\t\telse if (streq(optarg, \"zip\"))\n\t\t\t    compression = COMPRESSION_ADOBE_DEFLATE;\n\t\t\telse\n\t\t\t    usage(-1);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thorizSubSampling = atoi(optarg);\n\t\t\t<start_bug>\n\t\t\t\n\t\t\t<end_bug>\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvertSubSampling = atoi(optarg);\n            if( vertSubSampling != 1 && vertSubSampling != 2 && vertSubSampling != 4 )\n                usage(-1);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\t/* CCIR Rec 601-1 w/ headroom/footroom */\n\t\t\trefBlackWhite[0] = 16.;\n\t\t\trefBlackWhite[1] = 235.;\n\t\t\trefBlackWhite[2] = 128.;\n\t\t\trefBlackWhite[3] = 240.;\n\t\t\trefBlackWhite[4] = 128.;\n\t\t\trefBlackWhite[5] = 240.;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage(0);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage(-1);\n\tout = TIFFOpen(argv[argc-1], \"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\tsetupLumaTables();\n\tfor (; optind < argc-1; optind++) {\n\t\tin = TIFFOpen(argv[optind], \"r\");\n\t\tif (in != NULL) {\n\t\t\tdo {\n\t\t\t\tif (!tiffcvt(in, out) ||\n\t\t\t\t    !TIFFWriteDirectory(out)) {\n\t\t\t\t\t(void) TIFFClose(out);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t} while (TIFFReadDirectory(in));\n\t\t\t(void) TIFFClose(in);\n\t\t}\n\t}\n\t(void) TIFFClose(out);\n\treturn (0);\n}\n",
      "buggy_line_with_label_no": [39]
    },
     "libtiff-4": {
      "buggy_file": "tif_jpeg.c",
      "buggy_function": "static int JPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n\n\t\t/*\n\t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t * default value is inappropriate for YCbCr.  Fill in the\n\t\t * proper value if application didn't set it.\n\t\t */\n\t\t{\n\t\t\tfloat *ref;\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t  &ref)) {\n\t\t\t\tfloat refbw[6];\n\t\t\t\tlong top = 1L << td->td_bitspersample;\n\t\t\t\trefbw[0] = 0;\n\t\t\t\trefbw[1] = (float)(top-1L);\n\t\t\t\trefbw[2] = (float)(top>>1);\n\t\t\t\trefbw[3] = refbw[1];\n\t\t\t\trefbw[4] = refbw[2];\n\t\t\t\trefbw[5] = refbw[1];\n\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t     refbw);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\t\t/* disallowed by Tech Note */\n\tcase PHOTOMETRIC_MASK:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\n\t\t\t  (int) sp->photometric);\n\t\treturn (0);\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Verify miscellaneous parameters */\n\n\t/*\n\t * This would need work if libtiff ever supports different\n\t * depths for different components, or if libjpeg ever supports\n\t * run-time selection of depth.  Neither is imminent.\n\t */\n#ifdef JPEG_LIB_MK1\n        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */\n\tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) \n#else\n\tif (td->td_bitspersample != BITS_IN_JSAMPLE )\n#endif\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\n\t\t\t  (int) td->td_bitspersample);\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.data_precision = td->td_bitspersample;\n#ifdef JPEG_LIB_MK1\n        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;\n#endif\n\tif (isTiled(tif)) {\n\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile height must be multiple of %d\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile width must be multiple of %d\",\n\t\t\t\t  sp->h_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (td->td_rowsperstrip < td->td_imagelength &&\n\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Create a JPEGTables field if appropriate */\n\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {\n                if( sp->jpegtables == NULL\n                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )\n                {\n                        if (!prepare_JPEGTables(tif))\n                                return (0);\n                        /* Mark the field present */\n                        /* Can't use TIFFSetField since BEENWRITING is already set! */\n                        tif->tif_flags |= TIFF_DIRTYDIRECT;\n                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n                }\n\t} else {\n\t\t/* We do not support application-supplied JPEGTables, */\n\t\t/* so mark the field not present */\n\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\n\t}\n\n\t/* Direct libjpeg output to libtiff's output buffer */\n\tTIFFjpeg_data_dest(sp, tif);\n\n\treturn (1);\n}\n",
      "start_index": 1575,
      "end_index": 1731,
      "buggy_line_no": [53],
      "buggy_function_with_label": "static int JPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n        <start_bug>\n   \n     <end_bug>\n\t\t/*\n\t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t * default value is inappropriate for YCbCr.  Fill in the\n\t\t * proper value if application didn't set it.\n\t\t */\n\t\t{\n\t\t\tfloat *ref;\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t  &ref)) {\n\t\t\t\tfloat refbw[6];\n\t\t\t\tlong top = 1L << td->td_bitspersample;\n\t\t\t\trefbw[0] = 0;\n\t\t\t\trefbw[1] = (float)(top-1L);\n\t\t\t\trefbw[2] = (float)(top>>1);\n\t\t\t\trefbw[3] = refbw[1];\n\t\t\t\trefbw[4] = refbw[2];\n\t\t\t\trefbw[5] = refbw[1];\n\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t     refbw);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\t\t/* disallowed by Tech Note */\n\tcase PHOTOMETRIC_MASK:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\n\t\t\t  (int) sp->photometric);\n\t\treturn (0);\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Verify miscellaneous parameters */\n\n\t/*\n\t * This would need work if libtiff ever supports different\n\t * depths for different components, or if libjpeg ever supports\n\t * run-time selection of depth.  Neither is imminent.\n\t */\n#ifdef JPEG_LIB_MK1\n        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */\n\tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) \n#else\n\tif (td->td_bitspersample != BITS_IN_JSAMPLE )\n#endif\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\n\t\t\t  (int) td->td_bitspersample);\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.data_precision = td->td_bitspersample;\n#ifdef JPEG_LIB_MK1\n        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;\n#endif\n\tif (isTiled(tif)) {\n\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile height must be multiple of %d\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile width must be multiple of %d\",\n\t\t\t\t  sp->h_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (td->td_rowsperstrip < td->td_imagelength &&\n\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Create a JPEGTables field if appropriate */\n\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {\n                if( sp->jpegtables == NULL\n                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )\n                {\n                        if (!prepare_JPEGTables(tif))\n                                return (0);\n                        /* Mark the field present */\n                        /* Can't use TIFFSetField since BEENWRITING is already set! */\n                        tif->tif_flags |= TIFF_DIRTYDIRECT;\n                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n                }\n\t} else {\n\t\t/* We do not support application-supplied JPEGTables, */\n\t\t/* so mark the field not present */\n\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\n\t}\n\n\t/* Direct libjpeg output to libtiff's output buffer */\n\tTIFFjpeg_data_dest(sp, tif);\n\n\treturn (1);\n}\n",
      "buggy_line_with_label_no": [54]
    },
     "libtiff-5": {
      "buggy_file": "tif_strip.c",
      "buggy_function": "uint32 TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n\n    /* If the value was already computed and store in td_nstrips, then return it,\n       since ChopUpSingleUncompressedStrip might have altered and resized the\n       since the td_stripbytecount and td_stripoffset arrays to the new value\n       after the initial affectation of td_nstrips = TIFFNumberOfStrips() in\n       tif_dirread.c ~line 3612.\n       See http://bugzilla.maptools.org/show_bug.cgi?id=2587 */\n\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}\n",
      "start_index": 59,
      "end_index": 78,
      "buggy_line_no": [12],
      "buggy_function_with_label": "uint32 TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n\n    /* If the value was already computed and store in td_nstrips, then return it,\n       since ChopUpSingleUncompressedStrip might have altered and resized the\n       since the td_stripbytecount and td_stripoffset arrays to the new value\n       after the initial affectation of td_nstrips = TIFFNumberOfStrips() in\n       tif_dirread.c ~line 3612.\n       See http://bugzilla.maptools.org/show_bug.cgi?id=2587 */\n    <start_bug>\n  \n  <end_bug>\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}\n",
      "buggy_line_with_label_no": [13]
    },
    "berry-1":{
      "buggy_file": "be_vm.c",
      "buggy_function": "static void vm_exec(bvm *vm)\n{\n    bclosure *clos;\n    bvalue *ktab, *reg;\n    binstruction ins;\n    vm->cf->status |= BASE_FRAME;\nnewframe: /* a new call frame */\n    be_assert(var_isclosure(vm->cf->func));\n    clos = var_toobj(vm->cf->func);  /* `clos` is the current function/closure */\n    ktab = clos->proto->ktab;  /* `ktab` is the current constant table */\n    reg = vm->reg;  /* `reg` is the current stack base for the callframe */\n    vm_exec_loop() {\n        opcase(LDNIL): {\n            var_setnil(RA());\n            dispatch();\n        }\n        opcase(LDBOOL): {\n            bvalue *v = RA();\n            var_setbool(v, IGET_RKB(ins));\n            if (IGET_RKC(ins)) { /* skip next instruction */\n                vm->ip += 1;\n            }\n            dispatch();\n        }\n        opcase(LDINT): {\n            bvalue *v = RA();\n            var_setint(v, IGET_sBx(ins));\n            dispatch();\n        }\n        opcase(LDCONST): {\n            bvalue *dst = RA();\n            *dst = ktab[IGET_Bx(ins)];\n            dispatch();\n        }\n        opcase(GETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *v = *be_global_var(vm, idx);\n            dispatch();\n        }\n        opcase(GETNGBL): {  /* get Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_find(vm, name);\n                if (idx > -1) {\n                    *v = *be_global_var(vm, idx);\n                } else {\n                    vm_error(vm, \"attribute_error\", \"'%s' undeclared\", str(name));\n                }\n            } else {\n                vm_error(vm, \"internal_error\", \"global name must be a string\");\n            }\n            dispatch();\n        }\n        opcase(SETNGBL): {  /* set Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_new(vm, name);\n                *be_global_var(vm, idx) = *v;\n            } else {\n                vm_error(vm, \"internal_error\", \"global name must be a string\");\n            }\n            dispatch();\n        }\n        opcase(SETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *be_global_var(vm, idx) = *v;\n            dispatch();\n        }\n        opcase(GETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *v = *clos->upvals[idx]->value;\n            dispatch();\n        }\n        opcase(SETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *clos->upvals[idx]->value = *v;\n            dispatch();\n        }\n        opcase(MOVE): {\n            bvalue *dst = RA();\n            *dst = *RKB();\n            dispatch();\n        }\n        opcase(ADD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(+, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x + y);\n            } else if (var_isstr(a) && var_isstr(b)) { /* strcat */\n                bstring *s = be_strcat(vm, var_tostr(a), var_tostr(b));\n                reg = vm->reg;\n                dst = RA();\n                var_setstr(dst, s);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"+\", ins);\n            } else {\n                binop_error(vm, \"+\", a, b);\n            }\n            dispatch();\n        }\n        opcase(SUB): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(-, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x - y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"-\", ins);\n            } else {\n                binop_error(vm, \"-\", a, b);\n            }\n            dispatch();\n        }\n        opcase(MUL): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(*, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x * y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"*\", ins);\n            } else {\n                binop_error(vm, \"*\", a, b);\n            }\n            dispatch();\n        }\n        opcase(DIV): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                bint x = var_toint(a), y = var_toint(b);\n                if (y == 0) {\n                    vm_error(vm, \"divzero_error\", \"division by zero\");\n                } else {\n                    var_setint(dst, x / y);\n                }\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                if (y == cast(breal, 0)) {\n                    vm_error(vm, \"divzero_error\", \"division by zero\");\n                }\n                var_setreal(dst, x / y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"/\", ins);\n            } else {\n                binop_error(vm, \"/\", a, b);\n            }\n            dispatch();\n        }\n        opcase(MOD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(%, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                var_setreal(dst, mathfunc(fmod)(var_toreal(a), var_toreal(b)));\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"%\", ins);\n            } else {\n                binop_error(vm, \"%\", a, b);\n            }\n            dispatch();\n        }\n        opcase(LT): {\n            bbool res = be_vm_islt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(LE): {\n            bbool res = be_vm_isle(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(EQ): {\n            bbool res = be_vm_iseq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(NE): {\n            bbool res = be_vm_isneq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GT): {\n            bbool res = be_vm_isgt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GE): {\n            bbool res = be_vm_isge(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(CONNECT): {\n            bvalue *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                make_range(vm, *RKB(), *RKC());\n            } else if (var_isstr(a)) {\n                connect_str(vm, var_tostr(a), b);\n            } else if (var_isinstance(a)) {\n                object_binop(vm, \"..\", *RKB(), *RKC());\n            } else {\n                binop_error(vm, \"..\", RKB(), RKC());\n            }\n            reg = vm->reg;\n            *RA() = *vm->top; /* copy result to R(A) */\n            dispatch();\n        }\n        opcase(AND): {\n            bitwise_block(&);\n            dispatch();\n        }\n        opcase(OR): {\n            bitwise_block(|);\n            dispatch();\n        }\n        opcase(XOR): {\n            bitwise_block(^);\n            dispatch();\n        }\n        opcase(SHL): {\n            bitwise_block(<<);\n            dispatch();\n        }\n        opcase(SHR): {\n            bitwise_block(>>);\n            dispatch();\n        }\n        opcase(NEG): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isreal(a)) {\n                var_setreal(dst, -a->v.r);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, \"-*\", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, \"-\", a);\n            }\n            dispatch();\n        }\n        opcase(FLIP): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, \"~\", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, \"~\", a);\n            }\n            dispatch();\n        }\n        opcase(JMP): {\n            vm->ip += IGET_sBx(ins);\n            dispatch();\n        }\n        opcase(JMPT): {\n            if (be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(JMPF): {\n            if (!be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(CLOSURE): {\n            bvalue *dst;\n            bproto *p = clos->proto->ptab[IGET_Bx(ins)];\n            bclosure *cl = be_newclosure(vm, p->nupvals);\n            cl->proto = p;\n            reg = vm->reg;\n            dst = RA();\n            var_setclosure(dst, cl);\n            be_initupvals(vm, cl);\n            dispatch();\n        }\n        opcase(CLASS): {\n            bclass *c = var_toobj(ktab + IGET_Bx(ins));\n            be_class_upvalue_init(vm, c);\n            dispatch();\n        }\n        opcase(GETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n            } else if (var_isclass(b) && var_isstr(c)) {\n                class_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else {\n                attribute_error(vm, \"attribute\", b, c);\n            }\n            dispatch();\n        }\n        opcase(GETMET): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                binstance *obj = var_toobj(b);\n                int type = obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n                if (basetype(type) == BE_FUNCTION) {\n                    /* check if the object is a superinstance, if so get the lowest possible subclass */\n                    while (obj->sub) {\n                        obj = obj->sub;\n                    }\n                    var_setinstance(&a[1], obj);  /* replace superinstance by lowest subinstance */\n                } else {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' has no method '%s'\",\n                        str(be_instance_name(obj)), str(var_tostr(c)));\n                }\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, &a[1]);\n                var_settype(a, NOT_METHOD);\n            } else {\n                attribute_error(vm, \"method\", b, c);\n            }\n            dispatch();\n        }\n        opcase(SETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a) && var_isstr(b)) {\n                binstance *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_instance_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' cannot assign to attribute '%s'\",\n                        str(be_instance_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_isclass(a) && var_isstr(b)) {\n                bclass *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_class_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' cannot assign to static attribute '%s'\",\n                        str(be_class_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_ismodule(a) && var_isstr(b)) {\n                bmodule *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (be_module_setmember(vm, obj, attr, c)) {\n                    dispatch();\n                } else {\n                    // fall through exception below\n                }\n            }\n            attribute_error(vm, \"writable attribute\", a, b);\n            dispatch();\n        }\n        opcase(GETIDX): {\n            bvalue *b = RKB(), *c = RKC();\n            if (var_isinstance(b)) {\n                bvalue *top = vm->top;\n                /* get method 'item' */\n                obj_method(vm, b, str_literal(vm, \"item\"), vm->top);\n                top[1] = *b; /* move object to argv[0] */\n                top[2] = *c; /* move key to argv[1] */\n                vm->top += 3;   /* prevent collection results */\n                be_dofunc(vm, top, 2); /* call method 'item' */\n                vm->top -= 3;\n                reg = vm->reg;\n                *RA() = *vm->top;   /* copy result to R(A) */\n            } else if (var_isstr(b)) {\n                bstring *s = be_strindex(vm, var_tostr(b), c);\n                reg = vm->reg;\n                var_setstr(RA(), s);\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support subscriptable\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(SETIDX): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a)) {\n                bvalue *top = vm->top;\n                /* get method 'setitem' */\n                obj_method(vm, a, str_literal(vm, \"setitem\"), vm->top);\n                top[1] = *a; /* move object to argv[0] */\n                top[2] = *b; /* move key to argv[1] */\n                top[3] = *c; /* move src to argv[2] */\n                vm->top += 4;\n                be_dofunc(vm, top, 3); /* call method 'setitem' */\n                vm->top -= 4;\n                reg = vm->reg;\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support index assignment\",\n                    be_vtype2str(a));\n            }\n            dispatch();\n        }\n        opcase(SETSUPER): {\n            bvalue *a = RA(), *b = RKB();\n            if (var_isclass(a) && var_isclass(b)) {\n                bclass *obj = var_toobj(a);\n                be_class_setsuper(obj, var_toobj(b));\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support set super\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CLOSE): {\n            be_upvals_close(vm, RA());\n            dispatch();\n        }\n        opcase(IMPORT): {\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int res = be_module_load(vm, name);\n                reg = vm->reg;\n                switch (res) {\n                case BE_OK: /* find the module */\n                    be_stackpop(vm, 1);\n                    *RA() = *vm->top;\n                    break;\n                case BE_EXCEPTION: /* pop the exception value and message */\n                    be_pop(vm, 2);\n                    be_throw(vm, BE_EXCEPTION);\n                    break;\n                default:\n                    vm_error(vm, \"import_error\", \"module '%s' not found\", str(name));\n                }\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"import '%s' does not support import\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CATCH): {\n            bvalue *base = RA(), *top = vm->top;\n            int i = 0, ecnt = IGET_RKB(ins), vcnt = IGET_RKC(ins);\n            while (i < ecnt && !be_vm_iseq(vm, top, base + i)) {\n                ++i;\n            }\n            if (!ecnt || i < ecnt) { /* exception catched */\n                base = RA(), top = vm->top;\n                for (i = 0; i < vcnt; ++i) {\n                    *base++ = *top++;\n                }\n                vm->ip += 1; /* skip next instruction */\n            }\n            dispatch();\n        }\n        opcase(RAISE): {\n            if (IGET_RA(ins) < 2) {  /* A==2 means no arguments are passed to RAISE, i.e. rethrow with current exception */\n                bvalue *top = vm->top;\n                top[0] = *RKB(); /* push the exception value to top */\n                if (IGET_RA(ins)) { /* has exception argument? */\n                    top[1] = *RKC(); /* push the exception argument to top + 1 */\n                } else {\n                    var_setnil(top + 1);\n                }\n                be_save_stacktrace(vm);\n            }\n            be_throw(vm, BE_EXCEPTION); /* throw / rethrow the exception */\n            dispatch();\n        }\n        opcase(EXBLK): {\n            if (!IGET_RA(ins)) {\n                be_except_block_setup(vm);\n                if (be_setjmp(vm->errjmp->b)) {\n                    be_except_block_resume(vm);\n                    goto newframe;\n                }\n                reg = vm->reg;\n            } else {\n                be_except_block_close(vm, IGET_Bx(ins));\n            }\n            dispatch();\n        }\n        opcase(CALL): {\n            bvalue *var = RA();  /* `var` is the register for the call followed by arguments */\n            int mode = 0, argc = IGET_RKB(ins);  /* B contains number of arguments pushed on stack */\n        recall: /* goto: instantiation class and call constructor */\n            switch (var_type(var)) {\n            case NOT_METHOD:\n                var[0] = var[1];\n                ++var, --argc, mode = 1;\n                goto recall;\n            case BE_CLASS:\n                if (be_class_newobj(vm, var_toobj(var), var, ++argc, mode)) {  /* instanciate object and find constructor */\n                    reg = vm->reg + mode;  /* constructor found */\n                    mode = 0;\n                    var = RA() + 1; /* to next register */\n                    goto recall; /* call constructor */\n                }\n                break;\n            case BE_INSTANCE: {\n                bvalue *v = var + argc++, temp;\n                /* load the '()' method to `temp' */\n                obj_method(vm, var, str_literal(vm, \"()\"), &temp);\n                for (; v >= var; --v) v[1] = v[0];\n                *var = temp;\n                goto recall; /* call '()' method */\n            }\n            case BE_CLOSURE: {\n                // bvalue *v, *end;\n                // bproto *proto = var2cl(var)->proto;  /* get proto for closure */\n                // push_closure(vm, var, proto->nstack, mode);  /* prepare stack for closure */\n                // reg = vm->reg;  /* `reg` has changed, now new base register */\n                // v = reg + argc;  /* end of provided arguments */\n                // end = reg + proto->argc;  /* end of expected arguments */\n                // for (; v < end; ++v) {  /* set all not provided arguments to nil */\n                //     var_setnil(v);\n                // }\n                // if (proto->varg) {  /* there are vararg at the last argument, build the list */\n                //     /* code below uses mostly low-level calls for performance */\n                //     be_stack_require(vm, argc + 2);   /* make sure we don't overflow the stack */\n                //     bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the 'list' instance */\n                //     vm->top = v;  /* move top of stack right after last argument */\n                //     be_newobject(vm, \"list\");  /* this creates 2 objects on stack: list instance, BE_LIST object */\n                //     blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */\n                //     v = reg + proto->argc - 1;  /* last argument */\n                //     for (; v < reg + argc; v++) {\n                //         be_list_push(vm, list, v); /* push all varargs into list */       \n                //     }\n                //     *(reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */\n                //     vm->top = top_save;  /* restore top of stack pointer */\n                // }\n                prep_closure(vm, var, argc, mode);\n                reg = vm->reg;  /* `reg` has changed, now new base register */\n                goto newframe;  /* continue execution of the closure */\n            }\n            case BE_NTVCLOS: {\n                bntvclos *f = var_toobj(var);\n                push_native(vm, var, argc, mode);\n                f->f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_NTVFUNC: {\n                bntvfunc f = var_tontvfunc(var);\n                push_native(vm, var, argc, mode);\n                f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_MODULE: {\n                bvalue attr;\n                var_setstr(&attr, str_literal(vm, \"()\"));\n                module_attribute(vm, var, &attr, var);  /* exception if not found */\n                goto recall; /* call '()' method */\n                break;\n            }\n            default:\n                call_error(vm, var);\n            }\n            reg = vm->reg;\n            dispatch();\n        }\n        opcase(RET): {\n            bcallframe *cf;\n            bvalue *ret;\n#if BE_USE_DEBUG_HOOK\n            be_callhook(vm, BE_HOOK_RET);\n#endif\n            cf = vm->cf;\n            ret = vm->cf->func;\n            /* copy return value */\n            if (IGET_RA(ins)) {\n                *ret = *RKB();\n            } else {\n                var_setnil(ret);\n            }\n            vm->reg = cf->reg;\n            vm->top = cf->top;\n            vm->ip = cf->ip;\n            be_stack_pop(&vm->callstack); /* pop don't delete */\n            if (cf->status & BASE_FRAME) { /* entrance function */\n                bstack *cs = &vm->callstack;\n                if (!be_stack_isempty(cs)) {\n                    vm->cf = be_stack_top(cs);\n                }\n                return;\n            }\n            vm->cf = be_stack_top(&vm->callstack);\n            goto newframe;\n        }\n    }\n}\n",
      "start_index": 469,
      "end_index": 1100,
      "buggy_line_no": [277],
      "buggy_function_with_label": "static void vm_exec(bvm *vm)\n{\n    bclosure *clos;\n    bvalue *ktab, *reg;\n    binstruction ins;\n    vm->cf->status |= BASE_FRAME;\nnewframe: /* a new call frame */\n    be_assert(var_isclosure(vm->cf->func));\n    clos = var_toobj(vm->cf->func);  /* `clos` is the current function/closure */\n    ktab = clos->proto->ktab;  /* `ktab` is the current constant table */\n    reg = vm->reg;  /* `reg` is the current stack base for the callframe */\n    vm_exec_loop() {\n        opcase(LDNIL): {\n            var_setnil(RA());\n            dispatch();\n        }\n        opcase(LDBOOL): {\n            bvalue *v = RA();\n            var_setbool(v, IGET_RKB(ins));\n            if (IGET_RKC(ins)) { /* skip next instruction */\n                vm->ip += 1;\n            }\n            dispatch();\n        }\n        opcase(LDINT): {\n            bvalue *v = RA();\n            var_setint(v, IGET_sBx(ins));\n            dispatch();\n        }\n        opcase(LDCONST): {\n            bvalue *dst = RA();\n            *dst = ktab[IGET_Bx(ins)];\n            dispatch();\n        }\n        opcase(GETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *v = *be_global_var(vm, idx);\n            dispatch();\n        }\n        opcase(GETNGBL): {  /* get Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_find(vm, name);\n                if (idx > -1) {\n                    *v = *be_global_var(vm, idx);\n                } else {\n                    vm_error(vm, \"attribute_error\", \"'%s' undeclared\", str(name));\n                }\n            } else {\n                vm_error(vm, \"internal_error\", \"global name must be a string\");\n            }\n            dispatch();\n        }\n        opcase(SETNGBL): {  /* set Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_new(vm, name);\n                *be_global_var(vm, idx) = *v;\n            } else {\n                vm_error(vm, \"internal_error\", \"global name must be a string\");\n            }\n            dispatch();\n        }\n        opcase(SETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *be_global_var(vm, idx) = *v;\n            dispatch();\n        }\n        opcase(GETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *v = *clos->upvals[idx]->value;\n            dispatch();\n        }\n        opcase(SETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *clos->upvals[idx]->value = *v;\n            dispatch();\n        }\n        opcase(MOVE): {\n            bvalue *dst = RA();\n            *dst = *RKB();\n            dispatch();\n        }\n        opcase(ADD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(+, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x + y);\n            } else if (var_isstr(a) && var_isstr(b)) { /* strcat */\n                bstring *s = be_strcat(vm, var_tostr(a), var_tostr(b));\n                reg = vm->reg;\n                dst = RA();\n                var_setstr(dst, s);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"+\", ins);\n            } else {\n                binop_error(vm, \"+\", a, b);\n            }\n            dispatch();\n        }\n        opcase(SUB): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(-, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x - y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"-\", ins);\n            } else {\n                binop_error(vm, \"-\", a, b);\n            }\n            dispatch();\n        }\n        opcase(MUL): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(*, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x * y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"*\", ins);\n            } else {\n                binop_error(vm, \"*\", a, b);\n            }\n            dispatch();\n        }\n        opcase(DIV): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                bint x = var_toint(a), y = var_toint(b);\n                if (y == 0) {\n                    vm_error(vm, \"divzero_error\", \"division by zero\");\n                } else {\n                    var_setint(dst, x / y);\n                }\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                if (y == cast(breal, 0)) {\n                    vm_error(vm, \"divzero_error\", \"division by zero\");\n                }\n                var_setreal(dst, x / y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"/\", ins);\n            } else {\n                binop_error(vm, \"/\", a, b);\n            }\n            dispatch();\n        }\n        opcase(MOD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(%, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                var_setreal(dst, mathfunc(fmod)(var_toreal(a), var_toreal(b)));\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"%\", ins);\n            } else {\n                binop_error(vm, \"%\", a, b);\n            }\n            dispatch();\n        }\n        opcase(LT): {\n            bbool res = be_vm_islt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(LE): {\n            bbool res = be_vm_isle(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(EQ): {\n            bbool res = be_vm_iseq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(NE): {\n            bbool res = be_vm_isneq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GT): {\n            bbool res = be_vm_isgt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GE): {\n            bbool res = be_vm_isge(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(CONNECT): {\n            bvalue *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                make_range(vm, *RKB(), *RKC());\n            } else if (var_isstr(a)) {\n                connect_str(vm, var_tostr(a), b);\n            } else if (var_isinstance(a)) {\n                object_binop(vm, \"..\", *RKB(), *RKC());\n            } else {\n                binop_error(vm, \"..\", RKB(), RKC());\n            }\n            reg = vm->reg;\n            *RA() = *vm->top; /* copy result to R(A) */\n            dispatch();\n        }\n        opcase(AND): {\n            bitwise_block(&);\n            dispatch();\n        }\n        opcase(OR): {\n            bitwise_block(|);\n            dispatch();\n        }\n        opcase(XOR): {\n            bitwise_block(^);\n            dispatch();\n        }\n        opcase(SHL): {\n            bitwise_block(<<);\n            dispatch();\n        }\n        opcase(SHR): {\n            bitwise_block(>>);\n            dispatch();\n        }\n        opcase(NEG): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isreal(a)) {\n                var_setreal(dst, -a->v.r);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, \"-*\", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, \"-\", a);\n            }\n            dispatch();\n        }\n        opcase(FLIP): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n               <start_bug>\n                var_setint(dst, -a->v.i);\n               <end_bug>\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, \"~\", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, \"~\", a);\n            }\n            dispatch();\n        }\n        opcase(JMP): {\n            vm->ip += IGET_sBx(ins);\n            dispatch();\n        }\n        opcase(JMPT): {\n            if (be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(JMPF): {\n            if (!be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(CLOSURE): {\n            bvalue *dst;\n            bproto *p = clos->proto->ptab[IGET_Bx(ins)];\n            bclosure *cl = be_newclosure(vm, p->nupvals);\n            cl->proto = p;\n            reg = vm->reg;\n            dst = RA();\n            var_setclosure(dst, cl);\n            be_initupvals(vm, cl);\n            dispatch();\n        }\n        opcase(CLASS): {\n            bclass *c = var_toobj(ktab + IGET_Bx(ins));\n            be_class_upvalue_init(vm, c);\n            dispatch();\n        }\n        opcase(GETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n            } else if (var_isclass(b) && var_isstr(c)) {\n                class_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else {\n                attribute_error(vm, \"attribute\", b, c);\n            }\n            dispatch();\n        }\n        opcase(GETMET): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                binstance *obj = var_toobj(b);\n                int type = obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n                if (basetype(type) == BE_FUNCTION) {\n                    /* check if the object is a superinstance, if so get the lowest possible subclass */\n                    while (obj->sub) {\n                        obj = obj->sub;\n                    }\n                    var_setinstance(&a[1], obj);  /* replace superinstance by lowest subinstance */\n                } else {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' has no method '%s'\",\n                        str(be_instance_name(obj)), str(var_tostr(c)));\n                }\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, &a[1]);\n                var_settype(a, NOT_METHOD);\n            } else {\n                attribute_error(vm, \"method\", b, c);\n            }\n            dispatch();\n        }\n        opcase(SETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a) && var_isstr(b)) {\n                binstance *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_instance_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' cannot assign to attribute '%s'\",\n                        str(be_instance_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_isclass(a) && var_isstr(b)) {\n                bclass *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_class_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' cannot assign to static attribute '%s'\",\n                        str(be_class_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_ismodule(a) && var_isstr(b)) {\n                bmodule *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (be_module_setmember(vm, obj, attr, c)) {\n                    dispatch();\n                } else {\n                    // fall through exception below\n                }\n            }\n            attribute_error(vm, \"writable attribute\", a, b);\n            dispatch();\n        }\n        opcase(GETIDX): {\n            bvalue *b = RKB(), *c = RKC();\n            if (var_isinstance(b)) {\n                bvalue *top = vm->top;\n                /* get method 'item' */\n                obj_method(vm, b, str_literal(vm, \"item\"), vm->top);\n                top[1] = *b; /* move object to argv[0] */\n                top[2] = *c; /* move key to argv[1] */\n                vm->top += 3;   /* prevent collection results */\n                be_dofunc(vm, top, 2); /* call method 'item' */\n                vm->top -= 3;\n                reg = vm->reg;\n                *RA() = *vm->top;   /* copy result to R(A) */\n            } else if (var_isstr(b)) {\n                bstring *s = be_strindex(vm, var_tostr(b), c);\n                reg = vm->reg;\n                var_setstr(RA(), s);\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support subscriptable\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(SETIDX): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a)) {\n                bvalue *top = vm->top;\n                /* get method 'setitem' */\n                obj_method(vm, a, str_literal(vm, \"setitem\"), vm->top);\n                top[1] = *a; /* move object to argv[0] */\n                top[2] = *b; /* move key to argv[1] */\n                top[3] = *c; /* move src to argv[2] */\n                vm->top += 4;\n                be_dofunc(vm, top, 3); /* call method 'setitem' */\n                vm->top -= 4;\n                reg = vm->reg;\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support index assignment\",\n                    be_vtype2str(a));\n            }\n            dispatch();\n        }\n        opcase(SETSUPER): {\n            bvalue *a = RA(), *b = RKB();\n            if (var_isclass(a) && var_isclass(b)) {\n                bclass *obj = var_toobj(a);\n                be_class_setsuper(obj, var_toobj(b));\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support set super\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CLOSE): {\n            be_upvals_close(vm, RA());\n            dispatch();\n        }\n        opcase(IMPORT): {\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int res = be_module_load(vm, name);\n                reg = vm->reg;\n                switch (res) {\n                case BE_OK: /* find the module */\n                    be_stackpop(vm, 1);\n                    *RA() = *vm->top;\n                    break;\n                case BE_EXCEPTION: /* pop the exception value and message */\n                    be_pop(vm, 2);\n                    be_throw(vm, BE_EXCEPTION);\n                    break;\n                default:\n                    vm_error(vm, \"import_error\", \"module '%s' not found\", str(name));\n                }\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"import '%s' does not support import\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CATCH): {\n            bvalue *base = RA(), *top = vm->top;\n            int i = 0, ecnt = IGET_RKB(ins), vcnt = IGET_RKC(ins);\n            while (i < ecnt && !be_vm_iseq(vm, top, base + i)) {\n                ++i;\n            }\n            if (!ecnt || i < ecnt) { /* exception catched */\n                base = RA(), top = vm->top;\n                for (i = 0; i < vcnt; ++i) {\n                    *base++ = *top++;\n                }\n                vm->ip += 1; /* skip next instruction */\n            }\n            dispatch();\n        }\n        opcase(RAISE): {\n            if (IGET_RA(ins) < 2) {  /* A==2 means no arguments are passed to RAISE, i.e. rethrow with current exception */\n                bvalue *top = vm->top;\n                top[0] = *RKB(); /* push the exception value to top */\n                if (IGET_RA(ins)) { /* has exception argument? */\n                    top[1] = *RKC(); /* push the exception argument to top + 1 */\n                } else {\n                    var_setnil(top + 1);\n                }\n                be_save_stacktrace(vm);\n            }\n            be_throw(vm, BE_EXCEPTION); /* throw / rethrow the exception */\n            dispatch();\n        }\n        opcase(EXBLK): {\n            if (!IGET_RA(ins)) {\n                be_except_block_setup(vm);\n                if (be_setjmp(vm->errjmp->b)) {\n                    be_except_block_resume(vm);\n                    goto newframe;\n                }\n                reg = vm->reg;\n            } else {\n                be_except_block_close(vm, IGET_Bx(ins));\n            }\n            dispatch();\n        }\n        opcase(CALL): {\n            bvalue *var = RA();  /* `var` is the register for the call followed by arguments */\n            int mode = 0, argc = IGET_RKB(ins);  /* B contains number of arguments pushed on stack */\n        recall: /* goto: instantiation class and call constructor */\n            switch (var_type(var)) {\n            case NOT_METHOD:\n                var[0] = var[1];\n                ++var, --argc, mode = 1;\n                goto recall;\n            case BE_CLASS:\n                if (be_class_newobj(vm, var_toobj(var), var, ++argc, mode)) {  /* instanciate object and find constructor */\n                    reg = vm->reg + mode;  /* constructor found */\n                    mode = 0;\n                    var = RA() + 1; /* to next register */\n                    goto recall; /* call constructor */\n                }\n                break;\n            case BE_INSTANCE: {\n                bvalue *v = var + argc++, temp;\n                /* load the '()' method to `temp' */\n                obj_method(vm, var, str_literal(vm, \"()\"), &temp);\n                for (; v >= var; --v) v[1] = v[0];\n                *var = temp;\n                goto recall; /* call '()' method */\n            }\n            case BE_CLOSURE: {\n                // bvalue *v, *end;\n                // bproto *proto = var2cl(var)->proto;  /* get proto for closure */\n                // push_closure(vm, var, proto->nstack, mode);  /* prepare stack for closure */\n                // reg = vm->reg;  /* `reg` has changed, now new base register */\n                // v = reg + argc;  /* end of provided arguments */\n                // end = reg + proto->argc;  /* end of expected arguments */\n                // for (; v < end; ++v) {  /* set all not provided arguments to nil */\n                //     var_setnil(v);\n                // }\n                // if (proto->varg) {  /* there are vararg at the last argument, build the list */\n                //     /* code below uses mostly low-level calls for performance */\n                //     be_stack_require(vm, argc + 2);   /* make sure we don't overflow the stack */\n                //     bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the 'list' instance */\n                //     vm->top = v;  /* move top of stack right after last argument */\n                //     be_newobject(vm, \"list\");  /* this creates 2 objects on stack: list instance, BE_LIST object */\n                //     blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */\n                //     v = reg + proto->argc - 1;  /* last argument */\n                //     for (; v < reg + argc; v++) {\n                //         be_list_push(vm, list, v); /* push all varargs into list */       \n                //     }\n                //     *(reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */\n                //     vm->top = top_save;  /* restore top of stack pointer */\n                // }\n                prep_closure(vm, var, argc, mode);\n                reg = vm->reg;  /* `reg` has changed, now new base register */\n                goto newframe;  /* continue execution of the closure */\n            }\n            case BE_NTVCLOS: {\n                bntvclos *f = var_toobj(var);\n                push_native(vm, var, argc, mode);\n                f->f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_NTVFUNC: {\n                bntvfunc f = var_tontvfunc(var);\n                push_native(vm, var, argc, mode);\n                f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_MODULE: {\n                bvalue attr;\n                var_setstr(&attr, str_literal(vm, \"()\"));\n                module_attribute(vm, var, &attr, var);  /* exception if not found */\n                goto recall; /* call '()' method */\n                break;\n            }\n            default:\n                call_error(vm, var);\n            }\n            reg = vm->reg;\n            dispatch();\n        }\n        opcase(RET): {\n            bcallframe *cf;\n            bvalue *ret;\n#if BE_USE_DEBUG_HOOK\n            be_callhook(vm, BE_HOOK_RET);\n#endif\n            cf = vm->cf;\n            ret = vm->cf->func;\n            /* copy return value */\n            if (IGET_RA(ins)) {\n                *ret = *RKB();\n            } else {\n                var_setnil(ret);\n            }\n            vm->reg = cf->reg;\n            vm->top = cf->top;\n            vm->ip = cf->ip;\n            be_stack_pop(&vm->callstack); /* pop don't delete */\n            if (cf->status & BASE_FRAME) { /* entrance function */\n                bstack *cs = &vm->callstack;\n                if (!be_stack_isempty(cs)) {\n                    vm->cf = be_stack_top(cs);\n                }\n                return;\n            }\n            vm->cf = be_stack_top(&vm->callstack);\n            goto newframe;\n        }\n    }\n}\n",
      "buggy_line_with_label_no": [278]
    },
    "berry-2":{
      "buggy_file": "be_code.c",
      "buggy_function": "static void code_not(bfuncinfo *finfo, bexpdesc *e)\n{\n    switch (e->type) {\n    case ETINT: e->v.i = e->v.i == 0; break;\n    case ETREAL: e->v.i = e->v.r == cast(breal, 0); break;\n    case ETNIL: e->v.i = 1; break;\n    case ETBOOL: e->v.i = !e->v.i; break;\n    case ETSTRING: e->v.i = 0; break;\n    default: {\n        \n        int temp = e->t;\n        e->t = e->f;\n        e->f = temp;\n        e->not = NOT_EXPR | (e->not ^ NOT_MASK);\n        return;\n    }\n    }\n    e->type = ETBOOL;\n}\n",
      "start_index": 571,
      "end_index": 588,
      "buggy_line_no": [10],
      "buggy_function_with_label": "static void code_not(bfuncinfo *finfo, bexpdesc *e)\n{\n    switch (e->type) {\n    case ETINT: e->v.i = e->v.i == 0; break;\n    case ETREAL: e->v.i = e->v.r == cast(breal, 0); break;\n    case ETNIL: e->v.i = 1; break;\n    case ETBOOL: e->v.i = !e->v.i; break;\n    case ETSTRING: e->v.i = 0; break;\n    default: {\n        <start_bug>\n    \n    <end_bug>\n        int temp = e->t;\n        e->t = e->f;\n        e->f = temp;\n        e->not = NOT_EXPR | (e->not ^ NOT_MASK);\n        return;\n    }\n    }\n    e->type = ETBOOL;\n}\n",
      "buggy_line_with_label_no": [11]
    },
    "berry-3":{
      "buggy_file": "be_parser.c",
      "buggy_function": "static void class_inherit(bparser *parser, bexpdesc *e)\n{\n    if (next_type(parser) == OptColon) { /* ':' */\n        \n        bexpdesc e1;\n        scan_next_token(parser); /* skip ':' */\n        expr(parser, &e1);\n        check_var(parser, &e1);\n        be_code_setsuper(parser->finfo, e, &e1);\n    }\n}\n",
      "start_index": 1419,
      "end_index": 1428,
      "buggy_line_no": [4, 9],
      "buggy_function_with_label": "static void class_inherit(bparser *parser, bexpdesc *e)\n{\n    if (next_type(parser) == OptColon) { /* ':' */\n        <start_bug>\n   \n     <end_bug>\n        bexpdesc e1;\n        scan_next_token(parser); /* skip ':' */\n        expr(parser, &e1);\n        check_var(parser, &e1);\n        <start_bug>\n        be_code_setsuper(parser->finfo, e, &e1);\n        <end_bug>\n    }\n}",
      "buggy_line_with_label_no": [5, 12]
    },
    "berry-4":{
      "buggy_file": "be_strlib.c",
      "buggy_function": "static int str_format(bvm *vm)\n{\n    int top = be_top(vm);\n    if (top > 0 && be_isstring(vm, 1)) {\n        int index = 2;\n        const char *format = be_tostring(vm, 1);\n        pushstr(vm, \"\", 0);\n        for (;;) {\n            char mode[MAX_FORMAT_MODE];\n            char buf[128];\n            const char *p = strchr(format, '%');\n            if (p == NULL) {\n                break;\n            }\n            pushstr(vm, format, p - format);\n            concat2(vm);\n            p = get_mode(p + 1, mode);\n            buf[0] = '\\0';\n            if (index > top) {\n                be_raise(vm, \"runtime_error\", be_pushfstring(vm,\n                    \"bad argument #%d to 'format': no value\", index));\n            }\n            switch (*p) {\n            \n            case 'd': case 'i': case 'o':\n            case 'u': case 'x': case 'X':\n                if (be_isint(vm, index)) {\n                    mode_fixlen(mode, BE_INT_FMTLEN);\n                    sprintf(buf, mode, be_toint(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 'e': case 'E':\n            case 'f': case 'g': case 'G':\n                if (be_isnumber(vm, index)) {\n                    sprintf(buf, mode, be_toreal(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 'c':\n                if (be_isint(vm, index)) {\n                    sprintf(buf, \"%c\", (int)be_toint(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 's': {\n                const char *s = be_tostring(vm, index);\n                int len = be_strlen(vm, 2);\n                if (len > 100 && strlen(mode) == 2) {\n                    be_pushvalue(vm, index);\n                } else {\n                    sprintf(buf, mode, s);\n                    be_pushstring(vm, buf);\n                }\n                break;\n            }\n            default: /* error */\n                be_raise(vm, \"runtime_error\", be_pushfstring(vm,\n                    \"invalid option '%%%c' to 'format'\", *p));\n                break;\n            }\n            concat2(vm);\n            format = p + 1;\n            ++index;\n        }\n        pushstr(vm, format, strlen(format));\n        concat2(vm);\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}\n",
      "start_index": 496,
      "end_index": 565,
      "buggy_line_no": [19, 24],
      "buggy_function_with_label": "static int str_format(bvm *vm)\n{\n    int top = be_top(vm);\n    if (top > 0 && be_isstring(vm, 1)) {\n        int index = 2;\n        const char *format = be_tostring(vm, 1);\n        pushstr(vm, \"\", 0);\n        for (;;) {\n            char mode[MAX_FORMAT_MODE];\n            char buf[128];\n            const char *p = strchr(format, '%');\n            if (p == NULL) {\n                break;\n            }\n            pushstr(vm, format, p - format);\n            concat2(vm);\n            p = get_mode(p + 1, mode);\n            buf[0] = '\\0';\n            <start_bug>\n            if (index > top) {\n            <end_top>\n                be_raise(vm, \"runtime_error\", be_pushfstring(vm,\n                    \"bad argument #%d to 'format': no value\", index));\n            }\n            switch (*p) {\n            <start_bug>\n      \n      <end_bug>\n            case 'd': case 'i': case 'o':\n            case 'u': case 'x': case 'X':\n                if (be_isint(vm, index)) {\n                    mode_fixlen(mode, BE_INT_FMTLEN);\n                    sprintf(buf, mode, be_toint(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 'e': case 'E':\n            case 'f': case 'g': case 'G':\n                if (be_isnumber(vm, index)) {\n                    sprintf(buf, mode, be_toreal(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 'c':\n                if (be_isint(vm, index)) {\n                    sprintf(buf, \"%c\", (int)be_toint(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 's': {\n                const char *s = be_tostring(vm, index);\n                int len = be_strlen(vm, 2);\n                if (len > 100 && strlen(mode) == 2) {\n                    be_pushvalue(vm, index);\n                } else {\n                    sprintf(buf, mode, s);\n                    be_pushstring(vm, buf);\n                }\n                break;\n            }\n            default: /* error */\n                be_raise(vm, \"runtime_error\", be_pushfstring(vm,\n                    \"invalid option '%%%c' to 'format'\", *p));\n                break;\n            }\n            concat2(vm);\n            format = p + 1;\n            ++index;\n        }\n        pushstr(vm, format, strlen(format));\n        concat2(vm);\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}\n",
      "buggy_line_with_label_no": [20, 27]
    },
    "berry-5":{
      "buggy_file": "be_code.c",
      "buggy_function": "static void free_suffix(bfuncinfo *finfo, bexpdesc *e)\\n{\\n    int idx = e->v.ss.idx;\\n    int nlocal = be_list_count(finfo->local);\\n    /* release suffix register */\\n    if (!isK(idx) && idx >= nlocal) {\\n        be_code_freeregs(finfo, 1);\\n    }\\n    /* release object register */\\n    if (e->v.ss.tt == ETREG && (int)e->v.ss.obj >= nlocal) {\\n        be_code_freeregs(finfo, 1);\\n    }\\n}\\n",
      "start_index": 310,
      "end_index": 322,
      "buggy_line_no": [10],
      "buggy_function_with_label": "static void free_suffix(bfuncinfo *finfo, bexpdesc *e)\\n{\\n    int idx = e->v.ss.idx;\\n    int nlocal = be_list_count(finfo->local);\\n    /* release suffix register */\\n    if (!isK(idx) && idx >= nlocal) {\\n        be_code_freeregs(finfo, 1);\\n    }\\n    /* release object register */\\n<start_bug>\\n    if (e->v.ss.tt == ETREG && (int)e->v.ss.obj >= nlocal) {\\n<end_bug>\\n        be_code_freeregs(finfo, 1);\\n    }\\n}\\n",
      "buggy_line_with_label_no": [11]
    },
    "libucl-1": {
      "buggy_file": "ucl_emitter.c",
      "buggy_function": "static void\nucl_emit_msgpack_elt (struct ucl_emitter_context *ctx,\n\t\tconst ucl_object_t *obj, bool first, bool print_key)\n{\n\tucl_object_iter_t it;\n\tstruct ucl_object_userdata *ud;\n\tconst char *ud_out;\n\tconst ucl_object_t *cur, *celt;\n\n\tswitch (obj->type) {\n\tcase UCL_INT:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_int_msgpack (ctx, ucl_object_toint (obj));\n\t\tbreak;\n\n\tcase UCL_FLOAT:\n\tcase UCL_TIME:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_double_msgpack (ctx, ucl_object_todouble (obj));\n\t\tbreak;\n\n\tcase UCL_BOOLEAN:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_bool_msgpack (ctx, ucl_object_toboolean (obj));\n\t\tbreak;\n\n\tcase UCL_STRING:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_string_msgpack (ctx, obj->value.sv, obj->len);\n\t\tbreak;\n\n\tcase UCL_NULL:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_null_msgpack (ctx);\n\t\tbreak;\n\n\tcase UCL_OBJECT:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emit_msgpack_start_obj (ctx, obj, print_key);\n\t\tit = ucl_object_iterate_new (obj);\n\n\t\twhile ((cur = ucl_object_iterate_safe (it, true)) != NULL) {\n\t\t\tLL_FOREACH (cur, celt) {\n\t\t\t\tucl_emit_msgpack_elt (ctx, celt, false, true);\n\t\t\t\t/* XXX:\n\t\t\t\t * in msgpack the length of objects is encoded within a single elt\n\t\t\t\t * so in case of multi-value keys we are using merely the first\n\t\t\t\t * element ignoring others\n\t\t\t\t */\n\t\t\t\t \n\t\t\t}\n\t\t}\n\n\t\tucl_object_iterate_free (it);\n\t\tbreak;\n\n\tcase UCL_ARRAY:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emit_msgpack_start_array (ctx, obj, print_key);\n\t\tit = ucl_object_iterate_new (obj);\n\n\t\twhile ((cur = ucl_object_iterate_safe (it, true)) != NULL) {\n\t\t\tucl_emit_msgpack_elt (ctx, cur, false, false);\n\t\t}\n\n\t\tucl_object_iterate_free (it);\n\t\tbreak;\n\n\tcase UCL_USERDATA:\n\t\tud = (struct ucl_object_userdata *)obj;\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\n\t\tif (ud->emitter) {\n\t\t\tud_out = ud->emitter (obj->value.ud);\n\t\t\tif (ud_out == NULL) {\n\t\t\t\tud_out = \"null\";\n\t\t\t}\n\t\t}\n\t\tucl_emitter_print_string_msgpack (ctx, obj->value.sv, obj->len);\n\t\tbreak;\n\t}\n}",
      "start_index": 472,
      "end_index": 554,
      "buggy_line_no": [40, 42, 50, 54, 60, 62, 66],
      "buggy_function_with_label": "static void\nucl_emit_msgpack_elt (struct ucl_emitter_context *ctx,\n\t\tconst ucl_object_t *obj, bool first, bool print_key)\n{\n\tucl_object_iter_t it;\n\tstruct ucl_object_userdata *ud;\n\tconst char *ud_out;\n\tconst ucl_object_t *cur, *celt;\n\n\tswitch (obj->type) {\n\tcase UCL_INT:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_int_msgpack (ctx, ucl_object_toint (obj));\n\t\tbreak;\n\n\tcase UCL_FLOAT:\n\tcase UCL_TIME:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_double_msgpack (ctx, ucl_object_todouble (obj));\n\t\tbreak;\n\n\tcase UCL_BOOLEAN:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_bool_msgpack (ctx, ucl_object_toboolean (obj));\n\t\tbreak;\n\n\tcase UCL_STRING:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_string_msgpack (ctx, obj->value.sv, obj->len);\n\t\tbreak;\n\n\tcase UCL_NULL:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emitter_print_null_msgpack (ctx);\n\t\tbreak;\n\n\tcase UCL_OBJECT:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emit_msgpack_start_obj (ctx, obj, print_key);\n\t\t<start_bug>\n\t\tit = ucl_object_iterate_new (obj);\n        \n\t\twhile ((cur = ucl_object_iterate_safe (it, true)) != NULL) {\n\t\t<end_bug>\n\t\t\tLL_FOREACH (cur, celt) {\n\t\t\t\tucl_emit_msgpack_elt (ctx, celt, false, true);\n\t\t\t\t/* XXX:\n\t\t\t\t * in msgpack the length of objects is encoded within a single elt\n\t\t\t\t * so in case of multi-value keys we are using merely the first\n\t\t\t\t * element ignoring others\n\t\t\t\t */\n        <start_bug>\n        \n        <end_bug>\n\t\t\t}\n\t\t}\n    <start_bug>\n\t\tucl_object_iterate_free (it);\n\t\t<end_bug>\n\t\tbreak;\n\n\tcase UCL_ARRAY:\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\t\tucl_emit_msgpack_start_array (ctx, obj, print_key);\n\t\t<start_bug>\n\t\tit = ucl_object_iterate_new (obj);\n\n\t\twhile ((cur = ucl_object_iterate_safe (it, true)) != NULL) {\n\t\t<end_bug>\n\t\t\tucl_emit_msgpack_elt (ctx, cur, false, false);\n\t\t}\n        \n    <start_bug>\n\t\tucl_object_iterate_free (it);\n\t\t<end_bug>\n\t\tbreak;\n\n\tcase UCL_USERDATA:\n\t\tud = (struct ucl_object_userdata *)obj;\n\t\tucl_emitter_print_key_msgpack (print_key, ctx, obj);\n\n\t\tif (ud->emitter) {\n\t\t\tud_out = ud->emitter (obj->value.ud);\n\t\t\tif (ud_out == NULL) {\n\t\t\t\tud_out = \"null\";\n\t\t\t}\n\t\t}\n\t\tucl_emitter_print_string_msgpack (ctx, obj->value.sv, obj->len);\n\t\tbreak;\n\t}\n}\n",
      "buggy_line_with_label_no": [41, 43, 53, 58, 66, 68, 74]
    },
    "libucl-2": {
      "buggy_file": "ucl_parser.c",
      "buggy_function": "/**\n * Parse macro arguments as UCL object\n * @param parser parser structure\n * @param chunk the current data chunk\n * @return\n */\nstatic ucl_object_t *\nucl_parse_macro_arguments (struct ucl_parser *parser,\n\t\tstruct ucl_chunk *chunk)\n{\n\tucl_object_t *res = NULL;\n\tstruct ucl_parser *params_parser;\n\tint obraces = 1, ebraces = 0, state = 0;\n\tconst unsigned char *p, *c;\n\tsize_t args_len = 0;\n\tstruct ucl_parser_saved_state saved;\n\n\tsaved.column = chunk->column;\n\tsaved.line = chunk->line;\n\tsaved.pos = chunk->pos;\n\tsaved.remain = chunk->remain;\n\tp = chunk->pos;\n\n\tif (*p != '(' || chunk->remain < 2) {\n\t\treturn NULL;\n\t}\n\n\t/* Set begin and start */\n\tucl_chunk_skipc (chunk, p);\n\tc = p;\n\n\twhile ((p) < (chunk)->end) {\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\t/* Parse symbols and check for '(', ')' and '\"' */\n\t\t\tif (*p == '(') {\n\t\t\t\tobraces ++;\n\t\t\t}\n\t\t\telse if (*p == ')') {\n\t\t\t\tebraces ++;\n\t\t\t}\n\t\t\telse if (*p == '\"') {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\t/* Check pairing */\n\t\t\tif (obraces == ebraces) {\n\t\t\t\tstate = 99;\n\t\t\t}\n\t\t\telse {\n\t\t\t\targs_len ++;\n\t\t\t}\n\t\t\t/* Check overflow */\n\t\t\tif (chunk->remain == 0) {\n\t\t\t\tgoto restore_chunk;\n\t\t\t}\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* We have quote character, so skip all but quotes */\n\t\t\tif (*p == '\"' && *(p - 1) != '\\\\') {\n\t\t\t\tstate = 0;\n\t\t\t}\n\t\t\tif (chunk->remain == 0) {\n\t\t\t\tgoto restore_chunk;\n\t\t\t}\n      \n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\tbreak;\n\t\tcase 99:\n\t\t\t/*\n\t\t\t * We have read the full body of arguments, so we need to parse and set\n\t\t\t * object from that\n\t\t\t */\n\t\t\tparams_parser = ucl_parser_new (parser->flags);\n\t\t\tif (!ucl_parser_add_chunk (params_parser, c, args_len)) {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"macro arguments parsing error\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = ucl_parser_get_object (params_parser);\n\t\t\t}\n\t\t\tucl_parser_free (params_parser);\n\n\t\t\treturn res;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n\nrestore_chunk:\n\tchunk->column = saved.column;\n\tchunk->line = saved.line;\n\tchunk->pos = saved.pos;\n\tchunk->remain = saved.remain;\n\n\treturn NULL;\n}",
      "start_index": 1768,
      "end_index": 1866,
      "buggy_line_no": [66],
      "buggy_function_with_label": "/**\n * Parse macro arguments as UCL object\n * @param parser parser structure\n * @param chunk the current data chunk\n * @return\n */\nstatic ucl_object_t *\nucl_parse_macro_arguments (struct ucl_parser *parser,\n\t\tstruct ucl_chunk *chunk)\n{\n\tucl_object_t *res = NULL;\n\tstruct ucl_parser *params_parser;\n\tint obraces = 1, ebraces = 0, state = 0;\n\tconst unsigned char *p, *c;\n\tsize_t args_len = 0;\n\tstruct ucl_parser_saved_state saved;\n\n\tsaved.column = chunk->column;\n\tsaved.line = chunk->line;\n\tsaved.pos = chunk->pos;\n\tsaved.remain = chunk->remain;\n\tp = chunk->pos;\n\n\tif (*p != '(' || chunk->remain < 2) {\n\t\treturn NULL;\n\t}\n\n\t/* Set begin and start */\n\tucl_chunk_skipc (chunk, p);\n\tc = p;\n\n\twhile ((p) < (chunk)->end) {\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\t/* Parse symbols and check for '(', ')' and '\"' */\n\t\t\tif (*p == '(') {\n\t\t\t\tobraces ++;\n\t\t\t}\n\t\t\telse if (*p == ')') {\n\t\t\t\tebraces ++;\n\t\t\t}\n\t\t\telse if (*p == '\"') {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\t/* Check pairing */\n\t\t\tif (obraces == ebraces) {\n\t\t\t\tstate = 99;\n\t\t\t}\n\t\t\telse {\n\t\t\t\targs_len ++;\n\t\t\t}\n\t\t\t/* Check overflow */\n\t\t\tif (chunk->remain == 0) {\n\t\t\t\tgoto restore_chunk;\n\t\t\t}\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* We have quote character, so skip all but quotes */\n\t\t\tif (*p == '\"' && *(p - 1) != '\\\\') {\n\t\t\t\tstate = 0;\n\t\t\t}\n\t\t\tif (chunk->remain == 0) {\n\t\t\t\tgoto restore_chunk;\n\t\t\t}\n      <start_bug>\n      \n      <end_bug>\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\tbreak;\n\t\tcase 99:\n\t\t\t/*\n\t\t\t * We have read the full body of arguments, so we need to parse and set\n\t\t\t * object from that\n\t\t\t */\n\t\t\tparams_parser = ucl_parser_new (parser->flags);\n\t\t\tif (!ucl_parser_add_chunk (params_parser, c, args_len)) {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"macro arguments parsing error\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = ucl_parser_get_object (params_parser);\n\t\t\t}\n\t\t\tucl_parser_free (params_parser);\n\n\t\t\treturn res;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n\nrestore_chunk:\n\tchunk->column = saved.column;\n\tchunk->line = saved.line;\n\tchunk->pos = saved.pos;\n\tchunk->remain = saved.remain;\n\n\treturn NULL;\n}",
      "buggy_line_with_label_no": [67]
    },
    "libucl-3": {
      "buggy_file": "ucl_parser.c",
      "buggy_function": "/**\n * Parse a key in an object\n * @param parser\n * @param chunk\n * @return true if a key has been parsed\n */\nstatic bool\nucl_parse_key (struct ucl_parser *parser, struct ucl_chunk *chunk, bool *next_key, bool *end_of_object)\n{\n\tconst unsigned char *p, *c = NULL, *end, *t;\n\tconst char *key = NULL;\n\tbool got_quote = false, got_eq = false, got_semicolon = false,\n\t\t\tneed_unescape = false, ucl_escape = false, var_expand = false,\n\t\t\tgot_content = false, got_sep = false;\n\tucl_object_t *nobj, *tobj;\n\tucl_hash_t *container;\n\tssize_t keylen;\n\n\tp = chunk->pos;\n\n\tif (*p == '.') {\n\t\t/* It is macro actually */\n\t\tucl_chunk_skipc (chunk, p);\n\t\tparser->prev_state = parser->state;\n\t\tparser->state = UCL_STATE_MACRO_NAME;\n\n\t\treturn true;\n\t}\n\twhile (p < chunk->end) {\n\t\t/*\n\t\t * A key must start with alpha, number, '/' or '_' and end with space character\n\t\t */\n\t\tif (c == NULL) {\n\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp = chunk->pos;\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_START)) {\n\t\t\t\t/* The first symbol */\n\t\t\t\tc = p;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_content = true;\n\t\t\t}\n\t\t\telse if (*p == '\"') {\n\t\t\t\t/* JSON style key */\n\t\t\t\tc = p + 1;\n\t\t\t\tgot_quote = true;\n\t\t\t\tgot_content = true;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (*p == '}') {\n\t\t\t\t/* We have actually end of an object */\n\t\t\t\t*end_of_object = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (*p == '.') {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_MACRO_NAME;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Invalid identifier */\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"key must begin with a letter\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Parse the body of a key */\n\t\t\tif (!got_quote) {\n\t\t\t\tif (ucl_test_character (*p, UCL_CHARACTER_KEY)) {\n\t\t\t\t\tgot_content = true;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_SEP)) {\n\t\t\t\t\tend = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"invalid character in a key\",\n\t\t\t\t\t\t\t&parser->err);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* We need to parse json like quoted string */\n\t\t\t\tif (!ucl_lex_json_string (parser, chunk, &need_unescape, &ucl_escape, &var_expand)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Always escape keys obtained via json */\n\t\t\t\tend = chunk->pos - 1;\n\t\t\t\tp = chunk->pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\telse if (!got_content) {\n\t\treturn true;\n\t}\n\t*end_of_object = false;\n\t/* We are now at the end of the key, need to parse the rest */\n\twhile (p < chunk->end) {\n\t\tif (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t}\n\t\telse if (*p == '=') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_eq = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected '=' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (*p == ':') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_semicolon = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected ':' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t/* Check for comment */\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t}\n\t\telse {\n\t\t\t/* Start value */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\n\tgot_sep = got_semicolon || got_eq;\n\n\tif (!got_sep) {\n\t\t/*\n\t\t * Maybe we have more keys nested, so search for termination character.\n\t\t * Possible choices:\n\t\t * 1) key1 key2 ... keyN [:=] value <- we treat that as error\n\t\t * 2) key1 ... keyN {} or [] <- we treat that as nested objects\n\t\t * 3) key1 value[;,\\n] <- we treat that as linear object\n\t\t */\n\t\tt = p;\n\t\t*next_key = false;\n\t\twhile (ucl_test_character (*t, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tt ++;\n\t\t}\n\t\t/* Check first non-space character after a key */\n\t\tif (*t != '{' && *t != '[') {\n\t\t\twhile (t < chunk->end) {\n\t\t\t\tif (*t == ',' || *t == ';' || *t == '\\n' || *t == '\\r') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (*t == '{' || *t == '[') {\n\t\t\t\t\t*next_key = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Create a new object */\n\tnobj = ucl_object_new_full (UCL_NULL, parser->chunks->priority);\n\tkeylen = ucl_copy_or_store_ptr (parser, c, &nobj->trash_stack[UCL_TRASH_KEY],\n\t\t\t&key, end - c, need_unescape, parser->flags & UCL_PARSER_KEY_LOWERCASE, false);\n\tif (keylen == -1) {\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\telse if (keylen == 0) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"empty keys are not allowed\", &parser->err);\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\n\tcontainer = parser->stack->obj->value.ov;\n\tnobj->key = key;\n\tnobj->keylen = keylen;\n\ttobj = __DECONST (ucl_object_t *, ucl_hash_search_obj (container, nobj));\n\tif (tobj == NULL) {\n\t\tcontainer = ucl_hash_insert_object (container, nobj,\n\t\t\t\tparser->flags & UCL_PARSER_KEY_LOWERCASE);\n\t\tnobj->prev = nobj;\n\t\tnobj->next = NULL;\n\t\tparser->stack->obj->len ++;\n\t}\n\telse {\n\t\t/*\n\t\t * The logic here is the following:\n\t\t *\n\t\t * - if we have two objects with the same priority, then we form an\n\t\t * implicit or explicit array\n\t\t * - if a new object has bigger priority, then we overwrite an old one\n\t\t * - if a new object has lower priority, then we ignore it\n\t\t */\n\t\tunsigned priold = ucl_object_get_priority (tobj),\n\t\t\t\tprinew = ucl_object_get_priority (nobj);\n\t\tif (priold == prinew) {\n\t\t\tucl_parser_append_elt (parser, container, tobj, nobj);\n\t\t}\n\t\telse if (priold > prinew) {\n\t\t\tucl_object_unref (nobj);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tucl_hash_replace (container, tobj, nobj);\n\t\t\tucl_object_unref (tobj);\n\t\t}\n\t}\n\n\tif (ucl_escape) {\n\t\tnobj->flags |= UCL_OBJECT_NEED_KEY_ESCAPE;\n\t}\n\tparser->stack->obj->value.ov = container;\n\n\tparser->cur_obj = nobj;\n\n\treturn true;\n}",
      "start_index": 993,
      "end_index": 1236,
      "buggy_line_no": [26],
      "buggy_function_with_label": "/**\n * Parse a key in an object\n * @param parser\n * @param chunk\n * @return true if a key has been parsed\n */\nstatic bool\nucl_parse_key (struct ucl_parser *parser, struct ucl_chunk *chunk, bool *next_key, bool *end_of_object)\n{\n\tconst unsigned char *p, *c = NULL, *end, *t;\n\tconst char *key = NULL;\n\tbool got_quote = false, got_eq = false, got_semicolon = false,\n\t\t\tneed_unescape = false, ucl_escape = false, var_expand = false,\n\t\t\tgot_content = false, got_sep = false;\n\tucl_object_t *nobj, *tobj;\n\tucl_hash_t *container;\n\tssize_t keylen;\n\n\tp = chunk->pos;\n\n\tif (*p == '.') {\n\t\t/* It is macro actually */\n\t\tucl_chunk_skipc (chunk, p);\n\t\tparser->prev_state = parser->state;\n\t\tparser->state = UCL_STATE_MACRO_NAME;\n    <start_bug>\n\n    <end_bug>\n\t\treturn true;\n\t}\n\twhile (p < chunk->end) {\n\t\t/*\n\t\t * A key must start with alpha, number, '/' or '_' and end with space character\n\t\t */\n\t\tif (c == NULL) {\n\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp = chunk->pos;\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_START)) {\n\t\t\t\t/* The first symbol */\n\t\t\t\tc = p;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_content = true;\n\t\t\t}\n\t\t\telse if (*p == '\"') {\n\t\t\t\t/* JSON style key */\n\t\t\t\tc = p + 1;\n\t\t\t\tgot_quote = true;\n\t\t\t\tgot_content = true;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (*p == '}') {\n\t\t\t\t/* We have actually end of an object */\n\t\t\t\t*end_of_object = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (*p == '.') {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_MACRO_NAME;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Invalid identifier */\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"key must begin with a letter\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Parse the body of a key */\n\t\t\tif (!got_quote) {\n\t\t\t\tif (ucl_test_character (*p, UCL_CHARACTER_KEY)) {\n\t\t\t\t\tgot_content = true;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_SEP)) {\n\t\t\t\t\tend = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"invalid character in a key\",\n\t\t\t\t\t\t\t&parser->err);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* We need to parse json like quoted string */\n\t\t\t\tif (!ucl_lex_json_string (parser, chunk, &need_unescape, &ucl_escape, &var_expand)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Always escape keys obtained via json */\n\t\t\t\tend = chunk->pos - 1;\n\t\t\t\tp = chunk->pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\telse if (!got_content) {\n\t\treturn true;\n\t}\n\t*end_of_object = false;\n\t/* We are now at the end of the key, need to parse the rest */\n\twhile (p < chunk->end) {\n\t\tif (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t}\n\t\telse if (*p == '=') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_eq = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected '=' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (*p == ':') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_semicolon = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected ':' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t/* Check for comment */\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t}\n\t\telse {\n\t\t\t/* Start value */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\n\tgot_sep = got_semicolon || got_eq;\n\n\tif (!got_sep) {\n\t\t/*\n\t\t * Maybe we have more keys nested, so search for termination character.\n\t\t * Possible choices:\n\t\t * 1) key1 key2 ... keyN [:=] value <- we treat that as error\n\t\t * 2) key1 ... keyN {} or [] <- we treat that as nested objects\n\t\t * 3) key1 value[;,\\n] <- we treat that as linear object\n\t\t */\n\t\tt = p;\n\t\t*next_key = false;\n\t\twhile (ucl_test_character (*t, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tt ++;\n\t\t}\n\t\t/* Check first non-space character after a key */\n\t\tif (*t != '{' && *t != '[') {\n\t\t\twhile (t < chunk->end) {\n\t\t\t\tif (*t == ',' || *t == ';' || *t == '\\n' || *t == '\\r') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (*t == '{' || *t == '[') {\n\t\t\t\t\t*next_key = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Create a new object */\n\tnobj = ucl_object_new_full (UCL_NULL, parser->chunks->priority);\n\tkeylen = ucl_copy_or_store_ptr (parser, c, &nobj->trash_stack[UCL_TRASH_KEY],\n\t\t\t&key, end - c, need_unescape, parser->flags & UCL_PARSER_KEY_LOWERCASE, false);\n\tif (keylen == -1) {\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\telse if (keylen == 0) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"empty keys are not allowed\", &parser->err);\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\n\tcontainer = parser->stack->obj->value.ov;\n\tnobj->key = key;\n\tnobj->keylen = keylen;\n\ttobj = __DECONST (ucl_object_t *, ucl_hash_search_obj (container, nobj));\n\tif (tobj == NULL) {\n\t\tcontainer = ucl_hash_insert_object (container, nobj,\n\t\t\t\tparser->flags & UCL_PARSER_KEY_LOWERCASE);\n\t\tnobj->prev = nobj;\n\t\tnobj->next = NULL;\n\t\tparser->stack->obj->len ++;\n\t}\n\telse {\n\t\t/*\n\t\t * The logic here is the following:\n\t\t *\n\t\t * - if we have two objects with the same priority, then we form an\n\t\t * implicit or explicit array\n\t\t * - if a new object has bigger priority, then we overwrite an old one\n\t\t * - if a new object has lower priority, then we ignore it\n\t\t */\n\t\tunsigned priold = ucl_object_get_priority (tobj),\n\t\t\t\tprinew = ucl_object_get_priority (nobj);\n\t\tif (priold == prinew) {\n\t\t\tucl_parser_append_elt (parser, container, tobj, nobj);\n\t\t}\n\t\telse if (priold > prinew) {\n\t\t\tucl_object_unref (nobj);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tucl_hash_replace (container, tobj, nobj);\n\t\t\tucl_object_unref (tobj);\n\t\t}\n\t}\n\n\tif (ucl_escape) {\n\t\tnobj->flags |= UCL_OBJECT_NEED_KEY_ESCAPE;\n\t}\n\tparser->stack->obj->value.ov = container;\n\n\tparser->cur_obj = nobj;\n\n\treturn true;\n}",
      "buggy_line_with_label_no": [27]
    },
    "libucl-4": {
      "buggy_file": "ucl_parser.c",
      "buggy_function": "/**\n * Handle the main states of rcl parser\n * @param parser parser structure\n * @param data the pointer to the beginning of a chunk\n * @param len the length of a chunk\n * @return true if chunk has been parsed and false in case of error\n */\nstatic bool\nucl_state_machine (struct ucl_parser *parser)\n{\n\tucl_object_t *obj;\n\tstruct ucl_chunk *chunk = parser->chunks;\n\tconst unsigned char *p, *c = NULL, *macro_start = NULL;\n\tunsigned char *macro_escaped;\n\tsize_t macro_len = 0;\n\tstruct ucl_macro *macro = NULL;\n\tbool next_key = false, end_of_object = false;\n\n\tif (parser->top_obj == NULL) {\n\t\tif (*chunk->pos == '[') {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, true, 0);\n\t\t}\n\t\telse {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, false, 0);\n\t\t}\n\t\tif (obj == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tparser->top_obj = obj;\n\t\tparser->cur_obj = obj;\n\t\tparser->state = UCL_STATE_INIT;\n\t}\n\n\tp = chunk->pos;\n\twhile (chunk->pos < chunk->end) {\n\t\tswitch (parser->state) {\n\t\tcase UCL_STATE_INIT:\n\t\t\t/*\n\t\t\t * At the init state we can either go to the parse array or object\n\t\t\t * if we got [ or { correspondingly or can just treat new data as\n\t\t\t * a key of newly created object\n\t\t\t */\n\t\t\tobj = parser->cur_obj;\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip any spaces */\n        \n\t\t\t\tp = chunk->pos;\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t\tif (*p == '{') {\n\t\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_KEY:\n\t\t\t/* Skip any spaces */\n\t\t\twhile (p < chunk->end && ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\tif (*p == '}') {\n\t\t\t\t/* We have the end of an object */\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (parser->stack == NULL) {\n\t\t\t\t/* No objects are on stack, but we want to parse a key */\n\t\t\t\tucl_set_err (chunk, UCL_ESYNTAX, \"top object is finished but the parser \"\n\t\t\t\t\t\t\"expects a key\", &parser->err);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!ucl_parse_key (parser, chunk, &next_key, &end_of_object)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (end_of_object) {\n\t\t\t\tp = chunk->pos;\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (parser->state != UCL_STATE_MACRO_NAME) {\n\t\t\t\tif (next_key && parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\t/* Parse more keys and nest objects accordingly */\n\t\t\t\t\tobj = ucl_add_parser_stack (parser->cur_obj, parser, false,\n\t\t\t\t\t\t\tparser->stack->level + 1);\n\t\t\t\t\tif (obj == NULL) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = chunk->pos;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_VALUE:\n\t\t\t/* We need to check what we do have */\n\t\t\tif (!ucl_parse_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* State is set in ucl_parse_value call */\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_AFTER_VALUE:\n\t\t\tif (!ucl_parse_after_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parser->stack != NULL) {\n\t\t\t\tif (parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* Array */\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip everything at the end */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO_NAME:\n\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (p - c > 0) {\n\t\t\t\t/* We got macro name */\n\t\t\t\tmacro_len = (size_t)(p - c);\n\t\t\t\tHASH_FIND (hh, parser->macroes, c, macro_len, macro);\n\t\t\t\tif (macro == NULL) {\n\t\t\t\t\tucl_create_err (&parser->err, \"error on line %d at column %d: \"\n\t\t\t\t\t\t\t\"unknown macro: '%.*s', character: '%c'\",\n\t\t\t\t\t\t\t\tchunk->line, chunk->column, (int)(p - c), c, *chunk->pos);\n\t\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Now we need to skip all spaces */\n\t\t\t\twhile (p < chunk->end) {\n\t\t\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\t\t\t\t/* Skip comment */\n\t\t\t\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp = chunk->pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\tparser->state = UCL_STATE_MACRO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO:\n\t\t\tif (!ucl_parse_macro_value (parser, chunk, macro,\n\t\t\t\t\t&macro_start, &macro_len)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmacro_len = ucl_expand_variable (parser, &macro_escaped, macro_start, macro_len);\n\t\t\tparser->state = parser->prev_state;\n\t\t\tif (macro_escaped == NULL) {\n\t\t\t\tif (!macro->handler (macro_start, macro_len, macro->ud)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!macro->handler (macro_escaped, macro_len, macro->ud)) {\n\t\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TODO: add all states */\n\t\t\tucl_set_err (chunk, UCL_EINTERNAL, \"internal error: parser is in an unknown state\", &parser->err);\n\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
      "start_index": 1614,
      "end_index": 1819,
      "buggy_line_no": [51],
      "buggy_function_with_label": "/**\n * Handle the main states of rcl parser\n * @param parser parser structure\n * @param data the pointer to the beginning of a chunk\n * @param len the length of a chunk\n * @return true if chunk has been parsed and false in case of error\n */\nstatic bool\nucl_state_machine (struct ucl_parser *parser)\n{\n\tucl_object_t *obj;\n\tstruct ucl_chunk *chunk = parser->chunks;\n\tconst unsigned char *p, *c = NULL, *macro_start = NULL;\n\tunsigned char *macro_escaped;\n\tsize_t macro_len = 0;\n\tstruct ucl_macro *macro = NULL;\n\tbool next_key = false, end_of_object = false;\n\n\tif (parser->top_obj == NULL) {\n\t\tif (*chunk->pos == '[') {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, true, 0);\n\t\t}\n\t\telse {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, false, 0);\n\t\t}\n\t\tif (obj == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tparser->top_obj = obj;\n\t\tparser->cur_obj = obj;\n\t\tparser->state = UCL_STATE_INIT;\n\t}\n\n\tp = chunk->pos;\n\twhile (chunk->pos < chunk->end) {\n\t\tswitch (parser->state) {\n\t\tcase UCL_STATE_INIT:\n\t\t\t/*\n\t\t\t * At the init state we can either go to the parse array or object\n\t\t\t * if we got [ or { correspondingly or can just treat new data as\n\t\t\t * a key of newly created object\n\t\t\t */\n\t\t\tobj = parser->cur_obj;\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip any spaces */\n        <start_bug>\n\n        <end__bug>\n\t\t\t\tp = chunk->pos;\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t\tif (*p == '{') {\n\t\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_KEY:\n\t\t\t/* Skip any spaces */\n\t\t\twhile (p < chunk->end && ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\tif (*p == '}') {\n\t\t\t\t/* We have the end of an object */\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (parser->stack == NULL) {\n\t\t\t\t/* No objects are on stack, but we want to parse a key */\n\t\t\t\tucl_set_err (chunk, UCL_ESYNTAX, \"top object is finished but the parser \"\n\t\t\t\t\t\t\"expects a key\", &parser->err);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!ucl_parse_key (parser, chunk, &next_key, &end_of_object)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (end_of_object) {\n\t\t\t\tp = chunk->pos;\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (parser->state != UCL_STATE_MACRO_NAME) {\n\t\t\t\tif (next_key && parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\t/* Parse more keys and nest objects accordingly */\n\t\t\t\t\tobj = ucl_add_parser_stack (parser->cur_obj, parser, false,\n\t\t\t\t\t\t\tparser->stack->level + 1);\n\t\t\t\t\tif (obj == NULL) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = chunk->pos;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_VALUE:\n\t\t\t/* We need to check what we do have */\n\t\t\tif (!ucl_parse_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* State is set in ucl_parse_value call */\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_AFTER_VALUE:\n\t\t\tif (!ucl_parse_after_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parser->stack != NULL) {\n\t\t\t\tif (parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* Array */\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip everything at the end */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO_NAME:\n\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (p - c > 0) {\n\t\t\t\t/* We got macro name */\n\t\t\t\tmacro_len = (size_t)(p - c);\n\t\t\t\tHASH_FIND (hh, parser->macroes, c, macro_len, macro);\n\t\t\t\tif (macro == NULL) {\n\t\t\t\t\tucl_create_err (&parser->err, \"error on line %d at column %d: \"\n\t\t\t\t\t\t\t\"unknown macro: '%.*s', character: '%c'\",\n\t\t\t\t\t\t\t\tchunk->line, chunk->column, (int)(p - c), c, *chunk->pos);\n\t\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Now we need to skip all spaces */\n\t\t\t\twhile (p < chunk->end) {\n\t\t\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\t\t\t\t/* Skip comment */\n\t\t\t\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp = chunk->pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\tparser->state = UCL_STATE_MACRO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO:\n\t\t\tif (!ucl_parse_macro_value (parser, chunk, macro,\n\t\t\t\t\t&macro_start, &macro_len)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmacro_len = ucl_expand_variable (parser, &macro_escaped, macro_start, macro_len);\n\t\t\tparser->state = parser->prev_state;\n\t\t\tif (macro_escaped == NULL) {\n\t\t\t\tif (!macro->handler (macro_start, macro_len, macro->ud)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!macro->handler (macro_escaped, macro_len, macro->ud)) {\n\t\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TODO: add all states */\n\t\t\tucl_set_err (chunk, UCL_EINTERNAL, \"internal error: parser is in an unknown state\", &parser->err);\n\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
      "buggy_line_with_label_no": [52]
    },
    "libucl-5": {
      "buggy_file": "ucl_parser.c",
      "buggy_function": "/**\n * Parse a key in an object\n * @param parser\n * @param chunk\n * @return true if a key has been parsed\n */\nstatic bool\nucl_parse_key (struct ucl_parser *parser, struct ucl_chunk *chunk, bool *next_key, bool *end_of_object)\n{\n\tconst unsigned char *p, *c = NULL, *end, *t;\n\tconst char *key = NULL;\n\tbool got_quote = false, got_eq = false, got_semicolon = false,\n\t\t\tneed_unescape = false, ucl_escape = false, var_expand = false,\n\t\t\tgot_content = false, got_sep = false;\n\tucl_object_t *nobj, *tobj;\n\tucl_hash_t *container;\n\tssize_t keylen;\n\n\tp = chunk->pos;\n\n\tif (*p == '.') {\n\t\t/* It is macro actually */\n\t\tucl_chunk_skipc (chunk, p);\n\t\tparser->prev_state = parser->state;\n\t\tparser->state = UCL_STATE_MACRO_NAME;\n\n\t\treturn true;\n\t}\n\twhile (p < chunk->end) {\n\t\t/*\n\t\t * A key must start with alpha, number, '/' or '_' and end with space character\n\t\t */\n\t\tif (c == NULL) {\n\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp = chunk->pos;\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_START)) {\n\t\t\t\t/* The first symbol */\n\t\t\t\tc = p;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_content = true;\n\t\t\t}\n\t\t\telse if (*p == '\"') {\n\t\t\t\t/* JSON style key */\n\t\t\t\tc = p + 1;\n\t\t\t\tgot_quote = true;\n\t\t\t\tgot_content = true;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (*p == '}') {\n\t\t\t\t/* We have actually end of an object */\n\t\t\t\t*end_of_object = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (*p == '.') {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_MACRO_NAME;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Invalid identifier */\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"key must begin with a letter\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Parse the body of a key */\n\t\t\tif (!got_quote) {\n\t\t\t\tif (ucl_test_character (*p, UCL_CHARACTER_KEY)) {\n\t\t\t\t\tgot_content = true;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_SEP)) {\n\t\t\t\t\tend = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"invalid character in a key\",\n\t\t\t\t\t\t\t&parser->err);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* We need to parse json like quoted string */\n\t\t\t\tif (!ucl_lex_json_string (parser, chunk, &need_unescape, &ucl_escape, &var_expand)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Always escape keys obtained via json */\n\t\t\t\tend = chunk->pos - 1;\n\t\t\t\tp = chunk->pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\telse if (!got_content) {\n\t\treturn true;\n\t}\n\t*end_of_object = false;\n\t/* We are now at the end of the key, need to parse the rest */\n\twhile (p < chunk->end) {\n\t\tif (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t}\n\t\telse if (*p == '=') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_eq = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected '=' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (*p == ':') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_semicolon = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected ':' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t/* Check for comment */\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t}\n\t\telse {\n\t\t\t/* Start value */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\n\tgot_sep = got_semicolon || got_eq;\n\n\tif (!got_sep) {\n\t\t/*\n\t\t * Maybe we have more keys nested, so search for termination character.\n\t\t * Possible choices:\n\t\t * 1) key1 key2 ... keyN [:=] value <- we treat that as error\n\t\t * 2) key1 ... keyN {} or [] <- we treat that as nested objects\n\t\t * 3) key1 value[;,\\n] <- we treat that as linear object\n\t\t */\n\t\tt = p;\n\t\t*next_key = false;\n\t\twhile (ucl_test_character (*t, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tt ++;\n\t\t}\n\t\t/* Check first non-space character after a key */\n\t\tif (*t != '{' && *t != '[') {\n\t\t\twhile (t < chunk->end) {\n\t\t\t\tif (*t == ',' || *t == ';' || *t == '\\n' || *t == '\\r') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (*t == '{' || *t == '[') {\n\t\t\t\t\t*next_key = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Create a new object */\n\tnobj = ucl_object_new_full (UCL_NULL, parser->chunks->priority);\n\tkeylen = ucl_copy_or_store_ptr (parser, c, &nobj->trash_stack[UCL_TRASH_KEY],\n\t\t\t&key, end - c, need_unescape, parser->flags & UCL_PARSER_KEY_LOWERCASE, false);\n\tif (keylen == -1) {\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\telse if (keylen == 0) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"empty keys are not allowed\", &parser->err);\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\n\tcontainer = parser->stack->obj->value.ov;\n\tnobj->key = key;\n\tnobj->keylen = keylen;\n\ttobj = __DECONST (ucl_object_t *, ucl_hash_search_obj (container, nobj));\n\tif (tobj == NULL) {\n\t\tcontainer = ucl_hash_insert_object (container, nobj,\n\t\t\t\tparser->flags & UCL_PARSER_KEY_LOWERCASE);\n\t\tnobj->prev = nobj;\n\t\tnobj->next = NULL;\n\t\tparser->stack->obj->len ++;\n\t}\n\telse {\n\t\t/*\n\t\t * The logic here is the following:\n\t\t *\n\t\t * - if we have two objects with the same priority, then we form an\n\t\t * implicit or explicit array\n\t\t * - if a new object has bigger priority, then we overwrite an old one\n\t\t * - if a new object has lower priority, then we ignore it\n\t\t */\n\t\tunsigned priold = ucl_object_get_priority (tobj),\n\t\t\t\tprinew = ucl_object_get_priority (nobj);\n\t\tif (priold == prinew) {\n\t\t\tucl_parser_append_elt (parser, container, tobj, nobj);\n\t\t}\n\t\telse if (priold > prinew) {\n\t\t\tucl_object_unref (nobj);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tucl_hash_replace (container, tobj, nobj);\n\t\t\tucl_object_unref (tobj);\n\t\t}\n\t}\n\n\tif (ucl_escape) {\n\t\tnobj->flags |= UCL_OBJECT_NEED_KEY_ESCAPE;\n\t}\n\tparser->stack->obj->value.ov = container;\n\n\tparser->cur_obj = nobj;\n\n\treturn true;\n}",
      "start_index": 993,
      "end_index": 1236,
      "buggy_line_no": [26],
      "buggy_function_with_label": "/**\n * Parse a key in an object\n * @param parser\n * @param chunk\n * @return true if a key has been parsed\n */\nstatic bool\nucl_parse_key (struct ucl_parser *parser, struct ucl_chunk *chunk, bool *next_key, bool *end_of_object)\n{\n\tconst unsigned char *p, *c = NULL, *end, *t;\n\tconst char *key = NULL;\n\tbool got_quote = false, got_eq = false, got_semicolon = false,\n\t\t\tneed_unescape = false, ucl_escape = false, var_expand = false,\n\t\t\tgot_content = false, got_sep = false;\n\tucl_object_t *nobj, *tobj;\n\tucl_hash_t *container;\n\tssize_t keylen;\n\n\tp = chunk->pos;\n\n\tif (*p == '.') {\n\t\t/* It is macro actually */\n\t\tucl_chunk_skipc (chunk, p);\n\t\tparser->prev_state = parser->state;\n\t\tparser->state = UCL_STATE_MACRO_NAME;\n    <start_bug>\n\n    <end_bug>\n\t\treturn true;\n\t}\n\twhile (p < chunk->end) {\n\t\t/*\n\t\t * A key must start with alpha, number, '/' or '_' and end with space character\n\t\t */\n\t\tif (c == NULL) {\n\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp = chunk->pos;\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_START)) {\n\t\t\t\t/* The first symbol */\n\t\t\t\tc = p;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_content = true;\n\t\t\t}\n\t\t\telse if (*p == '\"') {\n\t\t\t\t/* JSON style key */\n\t\t\t\tc = p + 1;\n\t\t\t\tgot_quote = true;\n\t\t\t\tgot_content = true;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (*p == '}') {\n\t\t\t\t/* We have actually end of an object */\n\t\t\t\t*end_of_object = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (*p == '.') {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_MACRO_NAME;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Invalid identifier */\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"key must begin with a letter\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Parse the body of a key */\n\t\t\tif (!got_quote) {\n\t\t\t\tif (ucl_test_character (*p, UCL_CHARACTER_KEY)) {\n\t\t\t\t\tgot_content = true;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_SEP)) {\n\t\t\t\t\tend = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"invalid character in a key\",\n\t\t\t\t\t\t\t&parser->err);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* We need to parse json like quoted string */\n\t\t\t\tif (!ucl_lex_json_string (parser, chunk, &need_unescape, &ucl_escape, &var_expand)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Always escape keys obtained via json */\n\t\t\t\tend = chunk->pos - 1;\n\t\t\t\tp = chunk->pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\telse if (!got_content) {\n\t\treturn true;\n\t}\n\t*end_of_object = false;\n\t/* We are now at the end of the key, need to parse the rest */\n\twhile (p < chunk->end) {\n\t\tif (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t}\n\t\telse if (*p == '=') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_eq = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected '=' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (*p == ':') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_semicolon = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected ':' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t/* Check for comment */\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t}\n\t\telse {\n\t\t\t/* Start value */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\n\tgot_sep = got_semicolon || got_eq;\n\n\tif (!got_sep) {\n\t\t/*\n\t\t * Maybe we have more keys nested, so search for termination character.\n\t\t * Possible choices:\n\t\t * 1) key1 key2 ... keyN [:=] value <- we treat that as error\n\t\t * 2) key1 ... keyN {} or [] <- we treat that as nested objects\n\t\t * 3) key1 value[;,\\n] <- we treat that as linear object\n\t\t */\n\t\tt = p;\n\t\t*next_key = false;\n\t\twhile (ucl_test_character (*t, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tt ++;\n\t\t}\n\t\t/* Check first non-space character after a key */\n\t\tif (*t != '{' && *t != '[') {\n\t\t\twhile (t < chunk->end) {\n\t\t\t\tif (*t == ',' || *t == ';' || *t == '\\n' || *t == '\\r') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (*t == '{' || *t == '[') {\n\t\t\t\t\t*next_key = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Create a new object */\n\tnobj = ucl_object_new_full (UCL_NULL, parser->chunks->priority);\n\tkeylen = ucl_copy_or_store_ptr (parser, c, &nobj->trash_stack[UCL_TRASH_KEY],\n\t\t\t&key, end - c, need_unescape, parser->flags & UCL_PARSER_KEY_LOWERCASE, false);\n\tif (keylen == -1) {\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\telse if (keylen == 0) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"empty keys are not allowed\", &parser->err);\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\n\tcontainer = parser->stack->obj->value.ov;\n\tnobj->key = key;\n\tnobj->keylen = keylen;\n\ttobj = __DECONST (ucl_object_t *, ucl_hash_search_obj (container, nobj));\n\tif (tobj == NULL) {\n\t\tcontainer = ucl_hash_insert_object (container, nobj,\n\t\t\t\tparser->flags & UCL_PARSER_KEY_LOWERCASE);\n\t\tnobj->prev = nobj;\n\t\tnobj->next = NULL;\n\t\tparser->stack->obj->len ++;\n\t}\n\telse {\n\t\t/*\n\t\t * The logic here is the following:\n\t\t *\n\t\t * - if we have two objects with the same priority, then we form an\n\t\t * implicit or explicit array\n\t\t * - if a new object has bigger priority, then we overwrite an old one\n\t\t * - if a new object has lower priority, then we ignore it\n\t\t */\n\t\tunsigned priold = ucl_object_get_priority (tobj),\n\t\t\t\tprinew = ucl_object_get_priority (nobj);\n\t\tif (priold == prinew) {\n\t\t\tucl_parser_append_elt (parser, container, tobj, nobj);\n\t\t}\n\t\telse if (priold > prinew) {\n\t\t\tucl_object_unref (nobj);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tucl_hash_replace (container, tobj, nobj);\n\t\t\tucl_object_unref (tobj);\n\t\t}\n\t}\n\n\tif (ucl_escape) {\n\t\tnobj->flags |= UCL_OBJECT_NEED_KEY_ESCAPE;\n\t}\n\tparser->stack->obj->value.ov = container;\n\n\tparser->cur_obj = nobj;\n\n\treturn true;\n}",
      "buggy_line_with_label_no": [27]
    },
    "libucl-6": {
      "buggy_file": "ucl_parser.c",
      "buggy_function": "/**\n * Handle the main states of rcl parser\n * @param parser parser structure\n * @param data the pointer to the beginning of a chunk\n * @param len the length of a chunk\n * @return true if chunk has been parsed and false in case of error\n */\nstatic bool\nucl_state_machine (struct ucl_parser *parser)\n{\n\tucl_object_t *obj;\n\tstruct ucl_chunk *chunk = parser->chunks;\n\tconst unsigned char *p, *c = NULL, *macro_start = NULL;\n\tunsigned char *macro_escaped;\n\tsize_t macro_len = 0;\n\tstruct ucl_macro *macro = NULL;\n\tbool next_key = false, end_of_object = false;\n\n\tif (parser->top_obj == NULL) {\n\t\tif (*chunk->pos == '[') {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, true, 0);\n\t\t}\n\t\telse {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, false, 0);\n\t\t}\n\t\tif (obj == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tparser->top_obj = obj;\n\t\tparser->cur_obj = obj;\n\t\tparser->state = UCL_STATE_INIT;\n\t}\n\n\tp = chunk->pos;\n\twhile (chunk->pos < chunk->end) {\n\t\tswitch (parser->state) {\n\t\tcase UCL_STATE_INIT:\n\t\t\t/*\n\t\t\t * At the init state we can either go to the parse array or object\n\t\t\t * if we got [ or { correspondingly or can just treat new data as\n\t\t\t * a key of newly created object\n\t\t\t */\n\t\t\tobj = parser->cur_obj;\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip any spaces */\n        \n\t\t\t\tp = chunk->pos;\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t\tif (*p == '{') {\n\t\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_KEY:\n\t\t\t/* Skip any spaces */\n\t\t\twhile (p < chunk->end && ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\tif (*p == '}') {\n\t\t\t\t/* We have the end of an object */\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (parser->stack == NULL) {\n\t\t\t\t/* No objects are on stack, but we want to parse a key */\n\t\t\t\tucl_set_err (chunk, UCL_ESYNTAX, \"top object is finished but the parser \"\n\t\t\t\t\t\t\"expects a key\", &parser->err);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!ucl_parse_key (parser, chunk, &next_key, &end_of_object)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (end_of_object) {\n\t\t\t\tp = chunk->pos;\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (parser->state != UCL_STATE_MACRO_NAME) {\n\t\t\t\tif (next_key && parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\t/* Parse more keys and nest objects accordingly */\n\t\t\t\t\tobj = ucl_add_parser_stack (parser->cur_obj, parser, false,\n\t\t\t\t\t\t\tparser->stack->level + 1);\n\t\t\t\t\tif (obj == NULL) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = chunk->pos;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_VALUE:\n\t\t\t/* We need to check what we do have */\n\t\t\tif (!ucl_parse_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* State is set in ucl_parse_value call */\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_AFTER_VALUE:\n\t\t\tif (!ucl_parse_after_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parser->stack != NULL) {\n\t\t\t\tif (parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* Array */\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip everything at the end */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO_NAME:\n\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (p - c > 0) {\n\t\t\t\t/* We got macro name */\n\t\t\t\tmacro_len = (size_t)(p - c);\n\t\t\t\tHASH_FIND (hh, parser->macroes, c, macro_len, macro);\n\t\t\t\tif (macro == NULL) {\n\t\t\t\t\tucl_create_err (&parser->err, \"error on line %d at column %d: \"\n\t\t\t\t\t\t\t\"unknown macro: '%.*s', character: '%c'\",\n\t\t\t\t\t\t\t\tchunk->line, chunk->column, (int)(p - c), c, *chunk->pos);\n\t\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Now we need to skip all spaces */\n\t\t\t\twhile (p < chunk->end) {\n\t\t\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\t\t\t\t/* Skip comment */\n\t\t\t\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp = chunk->pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\tparser->state = UCL_STATE_MACRO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO:\n\t\t\tif (!ucl_parse_macro_value (parser, chunk, macro,\n\t\t\t\t\t&macro_start, &macro_len)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmacro_len = ucl_expand_variable (parser, &macro_escaped, macro_start, macro_len);\n\t\t\tparser->state = parser->prev_state;\n\t\t\tif (macro_escaped == NULL) {\n\t\t\t\tif (!macro->handler (macro_start, macro_len, macro->ud)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!macro->handler (macro_escaped, macro_len, macro->ud)) {\n\t\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TODO: add all states */\n\t\t\tucl_set_err (chunk, UCL_EINTERNAL, \"internal error: parser is in an unknown state\", &parser->err);\n\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
      "start_index": 1614,
      "end_index": 1819,
      "buggy_line_no": [51],
      "buggy_function_with_label": "/**\n * Handle the main states of rcl parser\n * @param parser parser structure\n * @param data the pointer to the beginning of a chunk\n * @param len the length of a chunk\n * @return true if chunk has been parsed and false in case of error\n */\nstatic bool\nucl_state_machine (struct ucl_parser *parser)\n{\n\tucl_object_t *obj;\n\tstruct ucl_chunk *chunk = parser->chunks;\n\tconst unsigned char *p, *c = NULL, *macro_start = NULL;\n\tunsigned char *macro_escaped;\n\tsize_t macro_len = 0;\n\tstruct ucl_macro *macro = NULL;\n\tbool next_key = false, end_of_object = false;\n\n\tif (parser->top_obj == NULL) {\n\t\tif (*chunk->pos == '[') {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, true, 0);\n\t\t}\n\t\telse {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, false, 0);\n\t\t}\n\t\tif (obj == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tparser->top_obj = obj;\n\t\tparser->cur_obj = obj;\n\t\tparser->state = UCL_STATE_INIT;\n\t}\n\n\tp = chunk->pos;\n\twhile (chunk->pos < chunk->end) {\n\t\tswitch (parser->state) {\n\t\tcase UCL_STATE_INIT:\n\t\t\t/*\n\t\t\t * At the init state we can either go to the parse array or object\n\t\t\t * if we got [ or { correspondingly or can just treat new data as\n\t\t\t * a key of newly created object\n\t\t\t */\n\t\t\tobj = parser->cur_obj;\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip any spaces */\n        <start_bug>\n\n        <end__bug>\n\t\t\t\tp = chunk->pos;\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t\tif (*p == '{') {\n\t\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_KEY:\n\t\t\t/* Skip any spaces */\n\t\t\twhile (p < chunk->end && ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\tif (*p == '}') {\n\t\t\t\t/* We have the end of an object */\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (parser->stack == NULL) {\n\t\t\t\t/* No objects are on stack, but we want to parse a key */\n\t\t\t\tucl_set_err (chunk, UCL_ESYNTAX, \"top object is finished but the parser \"\n\t\t\t\t\t\t\"expects a key\", &parser->err);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!ucl_parse_key (parser, chunk, &next_key, &end_of_object)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (end_of_object) {\n\t\t\t\tp = chunk->pos;\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (parser->state != UCL_STATE_MACRO_NAME) {\n\t\t\t\tif (next_key && parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\t/* Parse more keys and nest objects accordingly */\n\t\t\t\t\tobj = ucl_add_parser_stack (parser->cur_obj, parser, false,\n\t\t\t\t\t\t\tparser->stack->level + 1);\n\t\t\t\t\tif (obj == NULL) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = chunk->pos;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_VALUE:\n\t\t\t/* We need to check what we do have */\n\t\t\tif (!ucl_parse_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* State is set in ucl_parse_value call */\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_AFTER_VALUE:\n\t\t\tif (!ucl_parse_after_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parser->stack != NULL) {\n\t\t\t\tif (parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* Array */\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip everything at the end */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO_NAME:\n\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (p - c > 0) {\n\t\t\t\t/* We got macro name */\n\t\t\t\tmacro_len = (size_t)(p - c);\n\t\t\t\tHASH_FIND (hh, parser->macroes, c, macro_len, macro);\n\t\t\t\tif (macro == NULL) {\n\t\t\t\t\tucl_create_err (&parser->err, \"error on line %d at column %d: \"\n\t\t\t\t\t\t\t\"unknown macro: '%.*s', character: '%c'\",\n\t\t\t\t\t\t\t\tchunk->line, chunk->column, (int)(p - c), c, *chunk->pos);\n\t\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Now we need to skip all spaces */\n\t\t\t\twhile (p < chunk->end) {\n\t\t\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\t\t\t\t/* Skip comment */\n\t\t\t\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp = chunk->pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\tparser->state = UCL_STATE_MACRO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO:\n\t\t\tif (!ucl_parse_macro_value (parser, chunk, macro,\n\t\t\t\t\t&macro_start, &macro_len)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmacro_len = ucl_expand_variable (parser, &macro_escaped, macro_start, macro_len);\n\t\t\tparser->state = parser->prev_state;\n\t\t\tif (macro_escaped == NULL) {\n\t\t\t\tif (!macro->handler (macro_start, macro_len, macro->ud)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!macro->handler (macro_escaped, macro_len, macro->ud)) {\n\t\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TODO: add all states */\n\t\t\tucl_set_err (chunk, UCL_EINTERNAL, \"internal error: parser is in an unknown state\", &parser->err);\n\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
      "buggy_line_with_label_no": [52]
    }
  }