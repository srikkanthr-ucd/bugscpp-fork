test_result: 
exiv2-13: 
build_result: True
test_cases_result:  
pass_rate: 0.0
pass_test_cases: []
fail_test_cases: ['exiv2-buggy-13-4']
fail_test_cases_info: {'exiv2-buggy-13-4': {'failing_info': 'F\n======================================================================\nFAIL: test_run (test_issue_742.ThrowsWhenSubBoxLengthIsNotGood)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File "/home/workspace/tests/system_tests.py", line 632, in test_run\n    self.compare_stderr(i, command, processed_stderr, stderr)\n  File "/home/workspace/tests/system_tests.py", line 755, in compare_stderr\n    msg="Standard error does not match"\n  File "/home/workspace/tests/system_tests.py", line 726, in _compare_output\n    expected, got, msg=msg\nAssertionError: \'Uncaught exception: std::bad_alloc\\n\' != \'Exiv2 exception in print action for file [64 chars]ta\\n\'\n- Uncaught exception: std::bad_alloc\n+ Exiv2 exception in print action for file /home/workspace/test/data/issue_742_poc:\n+ corrupted image metadata\n : Standard error does not match\n\n----------------------------------------------------------------------\nRan 1 test in 0.078s\n\nFAILED (failures=1)\n', 'tc_code': 'ef test_run(self):\n    """\n    This function reads in the attributes commands, retval, stdout, stderr,\n    stdin and runs the `expand_variables` function on each. The resulting\n    commands are then run using the subprocess module and compared against the\n    expected values that were provided in the attributes via `compare_stdout`\n    and `compare_stderr`. Furthermore a threading.Timer is used to abort the\n    execution if a configured timeout is reached.\n\n    This function is automatically added as a member function to each system\n    test by the CaseMeta metaclass. This ensures that it is run by each system\n    test **after** setUp() and setUpClass() were run.\n    """\n    if not (len(self.commands) == len(self.retval)\n            == len(self.stdout) == len(self.stderr) == len(self.stdin)):\n        raise ValueError(\n            "commands, retval, stdout, stderr and stdin don\'t have the same "\n            "length"\n        )\n\n    for i, command, retval, stdout, stderr, stdin in \\\n        zip(range(len(self.commands)),\n            self.commands,\n            self.retval,\n            self.stdout,\n            self.stderr,\n            self.stdin):\n        command, retval, stdout, stderr, stdin = [\n            self.expand_variables(var) for var in\n            (command, retval, stdout, stderr, stdin)\n        ]\n\n        retval = int(retval)\n\n        if "memcheck" in _parameters:\n            command = _parameters["memcheck"] + " " + command\n\n        if _debug_mode:\n            print(\n                \'\', "="*80, "will run: " + command, "expected stdout:", stdout,\n                "expected stderr:", stderr,\n                "expected return value: {:d}".format(retval),\n                sep=\'\\n\'\n            )\n\n        proc = subprocess.Popen(\n            _cmd_splitter(command),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            stdin=subprocess.PIPE if stdin is not None else None,\n            env=self._get_env(),\n            cwd=self.work_dir,\n            shell=_SUBPROCESS_SHELL\n        )\n\n        # Setup a threading.Timer which will terminate the command if it takes\n        # too long. Don\'t use the timeout parameter in subprocess.Popen, since\n        # that is not available for all Python 3 versions.\n        # Use a dictionary to indicate a timeout, as booleans get passed by\n        # value and the changes made timeout_reached function will not be\n        # visible once it exits (the command will still be terminated once the\n        # timeout expires).\n        timeout = {"flag": False}\n\n        def timeout_reached(tmout):\n            tmout["flag"] = True\n            proc.kill()\n\n        t = threading.Timer(\n            _parameters["timeout"], timeout_reached, args=[timeout]\n        )\n\n        def get_encode_err():\n            """ Return an error message indicating that the encoding of stdin\n            failed.\n            """\n            return "Could not encode stdin {!s} for the command {!s} with the"\\\n                " following encodings: {!s}"\\\n                .format(stdin, command, \',\'.join(self.encodings))\n\n        # Prepare stdin: try to encode it or keep it at None if it was not\n        # provided\n        encoded_stdin = None\n        if stdin is not None:\n            encoded_stdin = self._encode(\n                stdin, lambda data_in, encoding: data_in.encode(encoding),\n                get_encode_err\n            )\n\n        if _debug_mode:\n            print(\'\', "stdin:", stdin or "", sep=\'\\n\')\n\n        t.start()\n        got_stdout, got_stderr = proc.communicate(input=encoded_stdin)\n        t.cancel()\n\n        def get_decode_error():\n            """ Return an error indicating the the decoding of stdout/stderr\n            failed.\n            """\n            return "Could not decode the output of the command \'{!s}\' with "\\\n                "the following encodings: {!s}"\\\n                .format(command, \',\'.join(self.encodings))\n\n        def decode_output(data_in, encoding):\n            """ Decode stdout/stderr, consider platform dependent line\n            endings.\n            """\n            return _process_output_post(data_in.decode(encoding))\n\n        processed_stdout, processed_stderr = [\n            self._encode(output, decode_output, get_decode_error)\n            for output in (got_stdout, got_stderr)\n        ]\n\n        if _debug_mode:\n            print(\n                "got stdout:", processed_stdout, "got stderr:",\n                processed_stderr, "got return value: {:d}"\n                .format(proc.returncode),\n                sep=\'\\n\'\n            )\n\n        self.assertFalse(timeout["flag"], msg="Timeout reached")\n        self.compare_stderr(i, command, processed_stderr, stderr)\n        self.compare_stdout(i, command, processed_stdout, stdout)\n        self.assertEqual(\n            retval, proc.returncode, msg="Return value does not match"\n        )\n\n        self.post_command_hook(i, command)\n\n    self.post_tests_hook()'}}
