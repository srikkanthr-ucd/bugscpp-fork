test_result: 
exiv2-20: 
build_result: True
test_cases_result:  
pass_rate: 0.0
pass_test_cases: []
fail_test_cases: ['exiv2-buggy-20-6', 'exiv2-buggy-20-4']
fail_test_cases_info: {'exiv2-buggy-20-6': {'failing_info': 'F\n======================================================================\nFAIL: test_run (test_issue_1969.TestPrintPlainWithSet)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File "/home/workspace/tests/system_tests.py", line 653, in test_run\n    self.compare_stdout(i, command, processed_stdout, stdout)\n  File "/home/workspace/tests/system_tests.py", line 768, in compare_stdout\n    msg="Standard output does not match"\n  File "/home/workspace/tests/system_tests.py", line 746, in _compare_output\n    expected, got, msg=msg\nAssertionError: \'set  Well it is a smiley that happens to be green\\n\' != \'set Exif.Image.ImageDescription              [57 chars]en\\n\'\n- set  Well it is a smiley that happens to be green\n+ set Exif.Image.ImageDescription                  Ascii      Well it is a smiley that happens to be green\n : Standard output does not match\n\n----------------------------------------------------------------------\nRan 1 test in 0.042s\n\nFAILED (failures=1)\n', 'tc_code': 'def test_run(self):\n    if not (len(self.commands) == len(self.retval)\n            == len(self.stdout) == len(self.stderr) == len(self.stdin)):\n        raise ValueError(\n            "commands, retval, stdout, stderr and stdin don\'t have the same "\n            "length"\n        )\n\n    for i, command, retval, stdout, stderr, stdin in \\\n        zip(range(len(self.commands)),\n            self.commands,\n            self.retval,\n            self.stdout,\n            self.stderr,\n            self.stdin):\n        command, retval, stdout, stderr, stdin = [\n            self.expand_variables(var) for var in\n            (command, retval, stdout, stderr, stdin)\n        ]\n\n        retval = int(retval)\n\n        if "memcheck" in _parameters:\n            command = _parameters["memcheck"] + " " + command\n\n        if _debug_mode:\n            print(\n                \'\', "="*80, "will run: " + command, "expected stdout:", stdout,\n                "expected stderr:", stderr,\n                "expected return value: {:d}".format(retval),\n                sep=\'\\n\'\n            )\n\n        proc = subprocess.Popen(\n            command,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            stdin=subprocess.PIPE if stdin is not None else None,\n            env=self._get_env(),\n            cwd=self.work_dir,\n            shell=True,\n        )\n\n        # Setup a threading.Timer which will terminate the command if it takes\n        # too long. Don\'t use the timeout parameter in subprocess.Popen, since\n        # that is not available for all Python 3 versions.\n        # Use a dictionary to indicate a timeout, as booleans get passed by\n        # value and the changes made timeout_reached function will not be\n        # visible once it exits (the command will still be terminated once the\n        # timeout expires).\n        timeout = {"flag": False}\n\n        def timeout_reached(tmout):\n            tmout["flag"] = True\n            proc.kill()\n\n        t = threading.Timer(\n            _parameters["timeout"], timeout_reached, args=[timeout]\n        )\n\n        def get_encode_err():\n            """ Return an error message indicating that the encoding of stdin\n            failed.\n            """\n            return "Could not encode stdin {!s} for the command {!s} with the"\\\n                " following encodings: {!s}"\\\n                .format(stdin, command, \',\'.join(self.encodings))\n\n        # Prepare stdin: try to encode it or keep it at None if it was not\n        # provided\n        encoded_stdin = None\n        if stdin is not None:\n            encoded_stdin = self._encode(\n                stdin, lambda data_in, encoding: data_in.encode(encoding),\n                get_encode_err\n            )\n\n        if _debug_mode:\n            print(\'\', "stdin:", stdin or "", sep=\'\\n\')\n\n        t.start()\n        got_stdout, got_stderr = proc.communicate(input=encoded_stdin)\n        t.cancel()\n\n        def get_decode_error():\n            """ Return an error indicating the the decoding of stdout/stderr\n            failed.\n            """\n            return "Could not decode the output of the command \'{!s}\' with "\\\n                "the following encodings: {!s}"\\\n                .format(command, \',\'.join(self.encodings))\n\n        def decode_output(data_in, encoding):\n            """ Decode stdout/stderr, consider platform dependent line\n            endings.\n            """\n            return _process_output_post(data_in.decode(encoding))\n\n        processed_stdout, processed_stderr = [\n            self._encode(output, decode_output, get_decode_error)\n            for output in (got_stdout, got_stderr)\n        ]\n\n        if _debug_mode:\n            print(\n                "got stdout:", processed_stdout, "got stderr:",\n                processed_stderr, "got return value: {:d}"\n                .format(proc.returncode),\n                sep=\'\\n\'\n            )\n\n        self.assertFalse(timeout["flag"], msg="Timeout reached")\n        self.compare_stderr(i, command, processed_stderr, stderr)\n        self.compare_stdout(i, command, processed_stdout, stdout)\n        self.assertEqual(\n            retval, proc.returncode, msg="Return value does not match"\n        )\n\n        self.post_command_hook(i, command)\n\n    self.post_tests_hook()'}, 'exiv2-buggy-20-4': {'failing_info': '...............s...F...............................................s........\n======================================================================\nFAIL: test_run (test_issue_1137.MetadataPiping)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File "/home/workspace/tests/system_tests.py", line 653, in test_run\n    self.compare_stdout(i, command, processed_stdout, stdout)\n  File "/home/workspace/tests/system_tests.py", line 768, in compare_stdout\n    msg="Standard output does not match"\n  File "/home/workspace/tests/system_tests.py", line 746, in _compare_output\n    expected, got, msg=msg\nAssertionError: \'set [40 chars]      N\\nset Exif.GPSInfo.GPSLatitude         [157 chars]/1\\n\' != \'set [40 chars]     Ascii      N\\nset Exif.GPSInfo.GPSLatitud[197 chars]/1\\n\'\n- set Exif.GPSInfo.GPSLatitudeRef                   N\n+ set Exif.GPSInfo.GPSLatitudeRef                  Ascii      N\n?                                                  ++++++++++\n- set Exif.GPSInfo.GPSLatitude                      51/1 106969/10000 0/1\n+ set Exif.GPSInfo.GPSLatitude                     Rational   51/1 106969/10000 0/1\n?                                                  ++++++++++\n- set Exif.GPSInfo.GPSLongitudeRef                  W\n+ set Exif.GPSInfo.GPSLongitudeRef                 Ascii      W\n?                                                  ++++++++++\n- set Exif.GPSInfo.GPSLongitude                     1/1 495984/10000 0/1\n+ set Exif.GPSInfo.GPSLongitude                    Rational   1/1 495984/10000 0/1\n?                                                  ++++++++++\n : Standard output does not match\n\n----------------------------------------------------------------------\nRan 76 tests in 12.246s\n\nFAILED (failures=1, skipped=2)\n', 'tc_code': 'def test_run(self):\n    if not (len(self.commands) == len(self.retval)\n            == len(self.stdout) == len(self.stderr) == len(self.stdin)):\n        raise ValueError(\n            "commands, retval, stdout, stderr and stdin don\'t have the same "\n            "length"\n        )\n\n    for i, command, retval, stdout, stderr, stdin in \\\n        zip(range(len(self.commands)),\n            self.commands,\n            self.retval,\n            self.stdout,\n            self.stderr,\n            self.stdin):\n        command, retval, stdout, stderr, stdin = [\n            self.expand_variables(var) for var in\n            (command, retval, stdout, stderr, stdin)\n        ]\n\n        retval = int(retval)\n\n        if "memcheck" in _parameters:\n            command = _parameters["memcheck"] + " " + command\n\n        if _debug_mode:\n            print(\n                \'\', "="*80, "will run: " + command, "expected stdout:", stdout,\n                "expected stderr:", stderr,\n                "expected return value: {:d}".format(retval),\n                sep=\'\\n\'\n            )\n\n        proc = subprocess.Popen(\n            command,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            stdin=subprocess.PIPE if stdin is not None else None,\n            env=self._get_env(),\n            cwd=self.work_dir,\n            shell=True,\n        )\n\n        # Setup a threading.Timer which will terminate the command if it takes\n        # too long. Don\'t use the timeout parameter in subprocess.Popen, since\n        # that is not available for all Python 3 versions.\n        # Use a dictionary to indicate a timeout, as booleans get passed by\n        # value and the changes made timeout_reached function will not be\n        # visible once it exits (the command will still be terminated once the\n        # timeout expires).\n        timeout = {"flag": False}\n\n        def timeout_reached(tmout):\n            tmout["flag"] = True\n            proc.kill()\n\n        t = threading.Timer(\n            _parameters["timeout"], timeout_reached, args=[timeout]\n        )\n\n        def get_encode_err():\n            """ Return an error message indicating that the encoding of stdin\n            failed.\n            """\n            return "Could not encode stdin {!s} for the command {!s} with the"\\\n                " following encodings: {!s}"\\\n                .format(stdin, command, \',\'.join(self.encodings))\n\n        # Prepare stdin: try to encode it or keep it at None if it was not\n        # provided\n        encoded_stdin = None\n        if stdin is not None:\n            encoded_stdin = self._encode(\n                stdin, lambda data_in, encoding: data_in.encode(encoding),\n                get_encode_err\n            )\n\n        if _debug_mode:\n            print(\'\', "stdin:", stdin or "", sep=\'\\n\')\n\n        t.start()\n        got_stdout, got_stderr = proc.communicate(input=encoded_stdin)\n        t.cancel()\n\n        def get_decode_error():\n            """ Return an error indicating the the decoding of stdout/stderr\n            failed.\n            """\n            return "Could not decode the output of the command \'{!s}\' with "\\\n                "the following encodings: {!s}"\\\n                .format(command, \',\'.join(self.encodings))\n\n        def decode_output(data_in, encoding):\n            """ Decode stdout/stderr, consider platform dependent line\n            endings.\n            """\n            return _process_output_post(data_in.decode(encoding))\n\n        processed_stdout, processed_stderr = [\n            self._encode(output, decode_output, get_decode_error)\n            for output in (got_stdout, got_stderr)\n        ]\n\n        if _debug_mode:\n            print(\n                "got stdout:", processed_stdout, "got stderr:",\n                processed_stderr, "got return value: {:d}"\n                .format(proc.returncode),\n                sep=\'\\n\'\n            )\n\n        self.assertFalse(timeout["flag"], msg="Timeout reached")\n        self.compare_stderr(i, command, processed_stderr, stderr)\n        self.compare_stdout(i, command, processed_stdout, stdout)\n        self.assertEqual(\n            retval, proc.returncode, msg="Return value does not match"\n        )\n\n        self.post_command_hook(i, command)\n\n    self.post_tests_hook()'}}
