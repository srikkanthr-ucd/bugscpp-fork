Repo berry-1 already exists
dict_values([['/********************************************************************\n** Copyright (c) 2018-2020 Guan Wenliang\n** This file is part of the Berry default interpreter.\n** skiars@qq.com, https://github.com/Skiars/berry\n** See Copyright Notice in the LICENSE file or at\n** https://github.com/Skiars/berry/blob/master/LICENSE\n********************************************************************/\n#include "be_vm.h"\n#include "be_decoder.h"\n#include "be_string.h"\n#include "be_strlib.h"\n#include "be_class.h"\n#include "be_func.h"\n#include "be_vector.h"\n#include "be_list.h"\n#include "be_map.h"\n#include "be_module.h"\n#include "be_mem.h"\n#include "be_var.h"\n#include "be_gc.h"\n#include "be_exec.h"\n#include "be_debug.h"\n#include "be_libs.h"\n#include <string.h>\n#include <math.h>\n\n#define NOT_METHOD          BE_NONE\n\n#define vm_error(vm, except, ...) \\\n    be_raise(vm, except, be_pushfstring(vm, __VA_ARGS__))\n\n#define RA()   (reg + IGET_RA(ins))  /* Get value of register A */\n#define RKB()  ((isKB(ins) ? ktab : reg) + KR2idx(IGET_RKB(ins)))  /* Get value of register or constant B */\n#define RKC()  ((isKC(ins) ? ktab : reg) + KR2idx(IGET_RKC(ins)))  /* Get value of register or constant C */\n\n#define var2cl(_v)          cast(bclosure*, var_toobj(_v))  /* cast var to closure */\n#define var2real(_v)        (var_isreal(_v) ? (_v)->v.r : (breal)(_v)->v.i)  /* get var as real or convert to real if integer */\n#define val2bool(v)         ((v) ? btrue : bfalse)  /* get var as bool (trur if non zero) */\n#define ibinop(op, a, b)    ((a)->v.i op (b)->v.i)  /* apply binary operator to both arguments as integers */\n\n#if BE_USE_DEBUG_HOOK\n  #define DEBUG_HOOK() \\\n    if (vm->hookmask & BE_HOOK_LINE) { \\\n        do_linehook(vm); \\\n        reg = vm->reg; \\\n    }\n#else\n  #define DEBUG_HOOK()\n#endif\n\n#define vm_exec_loop() \\\n    loop: \\\n        DEBUG_HOOK(); \\\n        switch (IGET_OP(ins = *vm->ip++))\n\n#if BE_USE_SINGLE_FLOAT\n  #define mathfunc(func)    func##f\n#else\n  #define mathfunc(func)    func\n#endif\n\n#define opcase(opcode)      case OP_##opcode\n#define dispatch()          goto loop\n\n#define equal_rule(op, iseq) \\\n    bbool res; \\\n    if (var_isint(a) && var_isint(b)) { \\\n        res = ibinop(op, a, b); \\\n    } else if (var_isnumber(a) && var_isnumber(b)) { \\\n        res = var2real(a) op var2real(b); \\\n    } else if (var_isinstance(a)) { \\\n        res = object_eqop(vm, #op, iseq, a, b); \\\n    } else if (var_type(a) == var_type(b)) { /* same types */ \\\n        if (var_isnil(a)) { /* nil op nil */ \\\n            res = 1 op 1; \\\n        } else if (var_isbool(a)) { /* bool op bool */ \\\n            res = var_tobool(a) op var_tobool(b); \\\n        } else if (var_isstr(a)) { /* string op string */ \\\n            res = 1 op be_eqstr(a->v.s, b->v.s); \\\n        } else if (var_isclass(a) || var_isfunction(a)) { \\\n            res = var_toobj(a) op var_toobj(b); \\\n        } else { \\\n            binop_error(vm, #op, a, b); \\\n            res = bfalse; /* will not be executed */ \\\n        } \\\n    } else { /* different types */ \\\n        res = 1 op 0; \\\n    } \\\n    return res\n\n#define relop_rule(op) \\\n    bbool res; \\\n    if (var_isint(a) && var_isint(b)) { \\\n        res = ibinop(op, a, b); \\\n    } else if (var_isnumber(a) && var_isnumber(b)) { \\\n        res = var2real(a) op var2real(b); \\\n    } else if (var_isstr(a) && var_isstr(b)) { \\\n        bstring *s1 = var_tostr(a), *s2 = var_tostr(b); \\\n        res = be_strcmp(s1, s2) op 0; \\\n    } else if (var_isinstance(a)) { \\\n        binstance *obj = var_toobj(a); \\\n        object_binop(vm, #op, *a, *b); \\\n        check_bool(vm, obj, #op); \\\n        res = var_tobool(vm->top); \\\n    } else { \\\n        binop_error(vm, #op, a, b); \\\n        res = bfalse; /* will not be executed */ \\\n    } \\\n    return res\n\n#define bitwise_block(op) \\\n    bvalue *dst = RA(), *a = RKB(), *b = RKC(); \\\n    if (var_isint(a) && var_isint(b)) { \\\n        var_setint(dst, ibinop(op, a, b)); \\\n    } else if (var_isinstance(a)) { \\\n        ins_binop(vm, #op, ins); \\\n    } else { \\\n        binop_error(vm, #op, a, b); \\\n    }\n\n#define push_native(_vm, _f, _ns, _t) { \\\n    precall(_vm, _f, _ns, _t); \\\n    _vm->cf->status = PRIM_FUNC; \\\n}\n\nstatic void prep_closure(bvm *vm, bvalue *reg, int argc, int mode);\n\nstatic void attribute_error(bvm *vm, const char *t, bvalue *b, bvalue *c)\n{\n    const char *attr = var_isstr(c) ? str(var_tostr(c)) : be_vtype2str(c);\n    vm_error(vm, "attribute_error",\n        "\'%s\' value has no %s \'%s\'", be_vtype2str(b), t, attr);\n}\n\nstatic void binop_error(bvm *vm, const char *op, bvalue *a, bvalue *b)\n{\n    vm_error(vm, "type_error",\n        "unsupported operand type(s) for %s: \'%s\' and \'%s\'",\n        op, be_vtype2str(a), be_vtype2str(b));\n}\n\nstatic void unop_error(bvm *vm, const char *op, bvalue *a)\n{\n    vm_error(vm, "type_error",\n        "unsupported operand type(s) for %s: \'%s\'",\n        op, be_vtype2str(a));\n}\n\nstatic void call_error(bvm *vm, bvalue *v)\n{\n    vm_error(vm, "type_error",\n        "\'%s\' value is not callable", be_vtype2str(v));\n}\n\n/* Check that the return value is bool or raise an exception */\n/* `obj` and `method` are only passed for error reporting */\nstatic void check_bool(bvm *vm, binstance *obj, const char *method)\n{\n    if (!var_isbool(vm->top)) {\n        const char *name = str(be_instance_name(obj));\n        vm_error(vm, "type_error",\n            "`%s::%s` return value error, the expected type is \'bool\'",\n            strlen(name) ? name : "<anonymous>", method);\n    }\n}\n\n#if BE_USE_DEBUG_HOOK\nstatic void do_linehook(bvm *vm)\n{\n    bcallframe *cf = vm->cf;\n    bclosure *cl = var_toobj(cf->func);\n    int pc = cast_int(vm->ip - cl->proto->code);\n    if (!pc || pc > cf->lineinfo->endpc) {\n        while (pc > cf->lineinfo->endpc)\n            cf->lineinfo++;\n        be_callhook(vm, BE_HOOK_LINE);\n    } else {\n        blineinfo *linfo = cf->lineinfo;\n        blineinfo *base = cl->proto->lineinfo;\n        while (linfo > base && pc <= linfo[-1].endpc)\n            linfo--;\n        if (cf->lineinfo != linfo) {\n            cf->lineinfo = linfo;\n            be_callhook(vm, BE_HOOK_LINE);\n        }\n    }\n}\n#endif\n\n/* Prepare the stack for the function/method call */\n/* `func` is a pointer to the function/method on the stack, it contains the closure before call and the result after the call */\n/* `nstackˋ is the stack depth used by the function (determined by compiler), we add BE_STACK_FREE_MIN as a safety margin */\nstatic void precall(bvm *vm, bvalue *func, int nstack, int mode)\n{\n    bcallframe *cf;\n    int expan = nstack + BE_STACK_FREE_MIN; /* `expan` is the minimum required space on the stack */\n    if (vm->stacktop < func + expan) {  /* do we have too little space left on the stack? */\n        size_t fpos = func - vm->stack;  /* compute offset of `func` from base stack, in case stack is reallocated and base address changes */\n        be_stack_expansion(vm, expan);  /* expand stack (vector object), warning stack address changes */\n        func = vm->stack + fpos;  /* recompute `func` address with new stack address */\n    }\n    be_stack_push(vm, &vm->callstack, NULL);  /* push a NULL value on callstack */\n    cf = be_stack_top(&vm->callstack);  /* get address of new callframe at top of callstack */\n    cf->func = func - mode;\n    cf->top = vm->top;  /* save previous stack top */\n    cf->reg = vm->reg;  /* save previous stack base */\n    vm->reg = func + 1;  /* new stack base is right after function */\n    vm->top = vm->reg + nstack; /* new stack top is above the registers used by the function, so we don´t mess with them */\n    vm->cf = cf;  /* set new current callframe */\n}\n\n/* Prepare call of closure, setting the instruction pointer (ip) */\nstatic void push_closure(bvm *vm, bvalue *func, int nstack, int mode)\n{\n    bclosure *cl = var_toobj(func);\n    precall(vm, func, nstack, mode);\n    vm->cf->ip = vm->ip;\n    vm->cf->status = NONE_FLAG;\n    vm->ip = cl->proto->code;\n#if BE_USE_DEBUG_HOOK\n    vm->cf->lineinfo = cl->proto->lineinfo;\n    be_callhook(vm, BE_HOOK_CALL);\n#endif\n}\n\nstatic void ret_native(bvm *vm)\n{\n    bcallframe *_cf = vm->cf;\n    vm->reg = _cf->reg;\n    vm->top = _cf->top;\n    be_stack_pop(&vm->callstack);\n    vm->cf = be_stack_top(&vm->callstack);\n}\n\nstatic bbool obj2bool(bvm *vm, bvalue *var)\n{\n    binstance *obj = var_toobj(var);\n    bstring *tobool = str_literal(vm, "tobool");\n    /* get operator method */\n    int type = be_instance_member(vm, obj, tobool, vm->top);\n    if (type != BE_NONE && type != BE_NIL) {\n        vm->top[1] = *var; /* move self to argv[0] */\n        be_dofunc(vm, vm->top, 1); /* call method \'tobool\' */\n        /* check the return value */\n        check_bool(vm, obj, "tobool");\n        return var_tobool(vm->top);\n    }\n    return btrue;\n}\n\nbbool be_value2bool(bvm *vm, bvalue *v)\n{\n    switch (var_basetype(v)) {\n    case BE_NIL:\n        return bfalse;\n    case BE_BOOL:\n        return var_tobool(v);\n    case BE_INT:\n        return val2bool(v->v.i);\n    case BE_REAL:\n        return val2bool(v->v.r);\n    case BE_INSTANCE:\n        return obj2bool(vm, v);\n    default:\n        return btrue;\n    }\n}\n\nstatic void obj_method(bvm *vm, bvalue *o, bstring *attr, bvalue *dst)\n{\n    binstance *obj = var_toobj(o);\n    int type = be_instance_member_simple(vm, obj, attr, dst);\n    if (basetype(type) != BE_FUNCTION) {\n        vm_error(vm, "attribute_error",\n            "the \'%s\' object has no method \'%s\'",\n            str(be_instance_name(obj)), str(attr));\n    }\n}\n\nstatic int obj_attribute(bvm *vm, bvalue *o, bstring *attr, bvalue *dst)\n{\n    binstance *obj = var_toobj(o);\n    int type = be_instance_member(vm, obj, attr, dst);\n    if (type == BE_NONE) {\n        vm_error(vm, "attribute_error",\n            "the \'%s\' object has no attribute \'%s\'",\n            str(be_instance_name(obj)), str(attr));\n    }\n    return type;\n}\n\nstatic int class_attribute(bvm *vm, bvalue *o, bvalue *c, bvalue *dst)\n{\n    bstring *attr = var_tostr(c);\n    bclass *obj = var_toobj(o);\n    int type = be_class_member(vm, obj, attr, dst);\n    if (type == BE_NONE || type == BE_INDEX) {\n        vm_error(vm, "attribute_error",\n            "the \'%s\' class has no static attribute \'%s\'",\n            str(obj->name), str(attr));\n    }\n    return type;\n}\n\nstatic int module_attribute(bvm *vm, bvalue *o, bvalue *c, bvalue *dst)\n{\n    bstring *attr = var_tostr(c);\n    bmodule *module = var_toobj(o);\n    int type = be_module_attr(vm, module, attr, dst);\n    if (type == BE_NONE) {\n        vm_error(vm, "attribute_error",\n            "module \'%s\' has no member \'%s\'",\n            be_module_name(module), str(attr));\n    }\n    return type;\n}\n\nstatic bbool object_eqop(bvm *vm,\n    const char *op, bbool iseq, bvalue *a, bvalue *b)\n{\n    binstance *o = var_toobj(a);\n    bvalue self = *a, other = *b;\n    bbool isself = var_isinstance(b) && o == var_toobj(b);\n    /* first, try to call the overloaded operator of the object */\n    int type = be_instance_member(vm, o, be_newstr(vm, op), vm->top);\n    if (basetype(type) == BE_FUNCTION) { /* call method */\n        bvalue *top = vm->top;\n        top[1] = self;  /* move self to argv[0] */\n        top[2] = other; /* move other to argv[1] */\n        be_incrtop(vm); /* prevent collection results */\n        be_dofunc(vm, top, 2); /* call method \'item\' */\n        be_stackpop(vm, 1);\n        check_bool(vm, o, op); /* check return value */\n        return var_tobool(vm->top); /* copy result to dst */\n    }\n    /* the default equal operation rule */\n    return iseq == isself; /* check object self */\n}\n\nstatic void object_binop(bvm *vm, const char *op, bvalue self, bvalue other)\n{\n    bvalue *top = vm->top;\n    /* get operator method (possible GC) */\n    obj_method(vm, &self, be_newstr(vm, op), vm->top);\n    top[1] = self; /* move self to argv[0] */\n    top[2] = other; /* move other to argv[1] */\n    be_incrtop(vm); /* prevent collection results */\n    be_dofunc(vm, top, 2); /* call method \'item\' */\n    be_stackpop(vm, 1);\n}\n\n#define ins_binop(vm, op, ins) { \\\n    object_binop(vm, op, *RKB(), *RKC()); \\\n    reg = vm->reg; \\\n    *RA() = *vm->top; /* copy result to dst */ \\\n}\n\nstatic void ins_unop(bvm *vm, const char *op, bvalue self)\n{\n    bvalue *top = vm->top;\n    /* get operator method (possible GC) */\n    obj_method(vm, &self, be_newstr(vm, op), vm->top);\n    top[1] = self; /* move self to argv[0] */\n    be_dofunc(vm, top, 1); /* call method \'item\' */\n}\n\nbbool be_vm_iseq(bvm *vm, bvalue *a, bvalue *b)\n{\n    equal_rule(==, btrue);\n}\n\nbbool be_vm_isneq(bvm *vm, bvalue *a, bvalue *b)\n{\n    equal_rule(!=, bfalse);\n}\n\nbbool be_vm_islt(bvm *vm, bvalue *a, bvalue *b)\n{\n    relop_rule(<);\n}\n\nbbool be_vm_isle(bvm *vm, bvalue *a, bvalue *b)\n{\n    relop_rule(<=);\n}\n\nbbool be_vm_isgt(bvm *vm, bvalue *a, bvalue *b)\n{\n    relop_rule(>);\n}\n\nbbool be_vm_isge(bvm *vm, bvalue *a, bvalue *b)\n{\n    relop_rule(>=);\n}\n\nstatic void make_range(bvm *vm, bvalue lower, bvalue upper)\n{\n    /* get method \'item\' (possible GC) */\n    int idx = be_builtin_find(vm, str_literal(vm, "range"));\n    bvalue *top = vm->top;\n    top[0] = *be_global_var(vm, idx);\n    top[1] = lower; /* move lower to argv[0] */\n    top[2] = upper; /* move upper to argv[1] */\n    vm->top += 3; /* prevent collection results */\n    be_dofunc(vm, top, 2); /* call method \'item\' */\n    vm->top -= 3;\n}\n\nstatic void connect_str(bvm *vm, bstring *a, bvalue *b)\n{\n    bstring *s;\n    if (var_isstr(b)) {\n        s = be_strcat(vm, a, var_tostr(b));\n        var_setstr(vm->top, s);\n    } else {\n        *vm->top++ = *b;\n        be_val2str(vm, -1);\n        b = vm->top - 1;\n        s = be_strcat(vm, a, var_tostr(b));\n        var_setstr(b, s);\n        vm->top -= 1;\n    }\n}\n\nBERRY_API bvm* be_vm_new(void)\n{\n    bvm *vm = be_os_malloc(sizeof(bvm));\n    be_assert(vm != NULL);\n    memset(vm, 0, sizeof(bvm)); /* clear all members */\n    be_gc_init(vm);\n    be_string_init(vm);\n    be_stack_init(vm, &vm->callstack, sizeof(bcallframe));\n    be_stack_init(vm, &vm->refstack, sizeof(binstance*));\n    be_stack_init(vm, &vm->exceptstack, sizeof(struct bexecptframe));\n    be_stack_init(vm, &vm->tracestack, sizeof(bcallsnapshot));\n    vm->stack = be_malloc(vm, sizeof(bvalue) * BE_STACK_FREE_MIN);\n    vm->stacktop = vm->stack + BE_STACK_FREE_MIN;\n    vm->reg = vm->stack;\n    vm->top = vm->reg;\n    be_globalvar_init(vm);\n    be_gc_setpause(vm, 1);\n    be_loadlibs(vm);\n    vm->compopt = 0;\n#if BE_USE_OBSERVABILITY_HOOK\n    vm->obshook = NULL;\n#endif\n    return vm;\n}\n\nBERRY_API void be_vm_delete(bvm *vm)\n{\n    be_gc_deleteall(vm);\n    be_string_deleteall(vm);\n    be_stack_delete(vm, &vm->callstack);\n    be_stack_delete(vm, &vm->refstack);\n    be_stack_delete(vm, &vm->exceptstack);\n    be_stack_delete(vm, &vm->tracestack);\n    be_free(vm, vm->stack, (vm->stacktop - vm->stack) * sizeof(bvalue));\n    be_globalvar_deinit(vm);\n#if BE_USE_DEBUG_HOOK\n    /* free native hook */\n    if (var_istype(&vm->hook, BE_COMPTR))\n        be_free(vm, var_toobj(&vm->hook), sizeof(struct bhookblock));\n#endif\n    /* free VM structure */\n    be_os_free(vm);\n}\n\nstatic void vm_exec(bvm *vm)\n{\n    bclosure *clos;\n    bvalue *ktab, *reg;\n    binstruction ins;\n    vm->cf->status |= BASE_FRAME;\nnewframe: /* a new call frame */\n    be_assert(var_isclosure(vm->cf->func));\n    clos = var_toobj(vm->cf->func);  /* `clos` is the current function/closure */\n    ktab = clos->proto->ktab;  /* `ktab` is the current constant table */\n    reg = vm->reg;  /* `reg` is the current stack base for the callframe */\n    vm_exec_loop() {\n        opcase(LDNIL): {\n            var_setnil(RA());\n            dispatch();\n        }\n        opcase(LDBOOL): {\n            bvalue *v = RA();\n            var_setbool(v, IGET_RKB(ins));\n            if (IGET_RKC(ins)) { /* skip next instruction */\n                vm->ip += 1;\n            }\n            dispatch();\n        }\n        opcase(LDINT): {\n            bvalue *v = RA();\n            var_setint(v, IGET_sBx(ins));\n            dispatch();\n        }\n        opcase(LDCONST): {\n            bvalue *dst = RA();\n            *dst = ktab[IGET_Bx(ins)];\n            dispatch();\n        }\n        opcase(GETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *v = *be_global_var(vm, idx);\n            dispatch();\n        }\n        opcase(GETNGBL): {  /* get Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_find(vm, name);\n                if (idx > -1) {\n                    *v = *be_global_var(vm, idx);\n                } else {\n                    vm_error(vm, "attribute_error", "\'%s\' undeclared", str(name));\n                }\n            } else {\n                vm_error(vm, "internal_error", "global name must be a string");\n            }\n            dispatch();\n        }\n        opcase(SETNGBL): {  /* set Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_new(vm, name);\n                *be_global_var(vm, idx) = *v;\n            } else {\n                vm_error(vm, "internal_error", "global name must be a string");\n            }\n            dispatch();\n        }\n        opcase(SETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *be_global_var(vm, idx) = *v;\n            dispatch();\n        }\n        opcase(GETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *v = *clos->upvals[idx]->value;\n            dispatch();\n        }\n        opcase(SETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *clos->upvals[idx]->value = *v;\n            dispatch();\n        }\n        opcase(MOVE): {\n            bvalue *dst = RA();\n            *dst = *RKB();\n            dispatch();\n        }\n        opcase(ADD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(+, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x + y);\n            } else if (var_isstr(a) && var_isstr(b)) { /* strcat */\n                bstring *s = be_strcat(vm, var_tostr(a), var_tostr(b));\n                reg = vm->reg;\n                dst = RA();\n                var_setstr(dst, s);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, "+", ins);\n            } else {\n                binop_error(vm, "+", a, b);\n            }\n            dispatch();\n        }\n        opcase(SUB): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(-, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x - y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, "-", ins);\n            } else {\n                binop_error(vm, "-", a, b);\n            }\n            dispatch();\n        }\n        opcase(MUL): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(*, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x * y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, "*", ins);\n            } else {\n                binop_error(vm, "*", a, b);\n            }\n            dispatch();\n        }\n        opcase(DIV): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                bint x = var_toint(a), y = var_toint(b);\n                if (y == 0) {\n                    vm_error(vm, "divzero_error", "division by zero");\n                } else {\n                    var_setint(dst, x / y);\n                }\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                if (y == cast(breal, 0)) {\n                    vm_error(vm, "divzero_error", "division by zero");\n                }\n                var_setreal(dst, x / y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, "/", ins);\n            } else {\n                binop_error(vm, "/", a, b);\n            }\n            dispatch();\n        }\n        opcase(MOD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(%, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                var_setreal(dst, mathfunc(fmod)(var_toreal(a), var_toreal(b)));\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, "%", ins);\n            } else {\n                binop_error(vm, "%", a, b);\n            }\n            dispatch();\n        }\n        opcase(LT): {\n            bbool res = be_vm_islt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(LE): {\n            bbool res = be_vm_isle(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(EQ): {\n            bbool res = be_vm_iseq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(NE): {\n            bbool res = be_vm_isneq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GT): {\n            bbool res = be_vm_isgt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GE): {\n            bbool res = be_vm_isge(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(CONNECT): {\n            bvalue *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                make_range(vm, *RKB(), *RKC());\n            } else if (var_isstr(a)) {\n                connect_str(vm, var_tostr(a), b);\n            } else if (var_isinstance(a)) {\n                object_binop(vm, "..", *RKB(), *RKC());\n            } else {\n                binop_error(vm, "..", RKB(), RKC());\n            }\n            reg = vm->reg;\n            *RA() = *vm->top; /* copy result to R(A) */\n            dispatch();\n        }\n        opcase(AND): {\n            bitwise_block(&);\n            dispatch();\n        }\n        opcase(OR): {\n            bitwise_block(|);\n            dispatch();\n        }\n        opcase(XOR): {\n            bitwise_block(^);\n            dispatch();\n        }\n        opcase(SHL): {\n            bitwise_block(<<);\n            dispatch();\n        }\n        opcase(SHR): {\n            bitwise_block(>>);\n            dispatch();\n        }\n        opcase(NEG): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isreal(a)) {\n                var_setreal(dst, -a->v.r);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, "-*", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, "-", a);\n            }\n            dispatch();\n        }\n        opcase(FLIP): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, "~", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, "~", a);\n            }\n            dispatch();\n        }\n        opcase(JMP): {\n            vm->ip += IGET_sBx(ins);\n            dispatch();\n        }\n        opcase(JMPT): {\n            if (be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(JMPF): {\n            if (!be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(CLOSURE): {\n            bvalue *dst;\n            bproto *p = clos->proto->ptab[IGET_Bx(ins)];\n            bclosure *cl = be_newclosure(vm, p->nupvals);\n            cl->proto = p;\n            reg = vm->reg;\n            dst = RA();\n            var_setclosure(dst, cl);\n            be_initupvals(vm, cl);\n            dispatch();\n        }\n        opcase(CLASS): {\n            bclass *c = var_toobj(ktab + IGET_Bx(ins));\n            be_class_upvalue_init(vm, c);\n            dispatch();\n        }\n        opcase(GETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n            } else if (var_isclass(b) && var_isstr(c)) {\n                class_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else {\n                attribute_error(vm, "attribute", b, c);\n            }\n            dispatch();\n        }\n        opcase(GETMET): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                binstance *obj = var_toobj(b);\n                int type = obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n                if (basetype(type) == BE_FUNCTION) {\n                    /* check if the object is a superinstance, if so get the lowest possible subclass */\n                    while (obj->sub) {\n                        obj = obj->sub;\n                    }\n                    var_setinstance(&a[1], obj);  /* replace superinstance by lowest subinstance */\n                } else {\n                    vm_error(vm, "attribute_error",\n                        "class \'%s\' has no method \'%s\'",\n                        str(be_instance_name(obj)), str(var_tostr(c)));\n                }\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, &a[1]);\n                var_settype(a, NOT_METHOD);\n            } else {\n                attribute_error(vm, "method", b, c);\n            }\n            dispatch();\n        }\n        opcase(SETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a) && var_isstr(b)) {\n                binstance *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_instance_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, "attribute_error",\n                        "class \'%s\' cannot assign to attribute \'%s\'",\n                        str(be_instance_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_isclass(a) && var_isstr(b)) {\n                bclass *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_class_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, "attribute_error",\n                        "class \'%s\' cannot assign to static attribute \'%s\'",\n                        str(be_class_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_ismodule(a) && var_isstr(b)) {\n                bmodule *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (be_module_setmember(vm, obj, attr, c)) {\n                    dispatch();\n                } else {\n                    // fall through exception below\n                }\n            }\n            attribute_error(vm, "writable attribute", a, b);\n            dispatch();\n        }\n        opcase(GETIDX): {\n            bvalue *b = RKB(), *c = RKC();\n            if (var_isinstance(b)) {\n                bvalue *top = vm->top;\n                /* get method \'item\' */\n                obj_method(vm, b, str_literal(vm, "item"), vm->top);\n                top[1] = *b; /* move object to argv[0] */\n                top[2] = *c; /* move key to argv[1] */\n                vm->top += 3;   /* prevent collection results */\n                be_dofunc(vm, top, 2); /* call method \'item\' */\n                vm->top -= 3;\n                reg = vm->reg;\n                *RA() = *vm->top;   /* copy result to R(A) */\n            } else if (var_isstr(b)) {\n                bstring *s = be_strindex(vm, var_tostr(b), c);\n                reg = vm->reg;\n                var_setstr(RA(), s);\n            } else {\n                vm_error(vm, "type_error",\n                    "value \'%s\' does not support subscriptable",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(SETIDX): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a)) {\n                bvalue *top = vm->top;\n                /* get method \'setitem\' */\n                obj_method(vm, a, str_literal(vm, "setitem"), vm->top);\n                top[1] = *a; /* move object to argv[0] */\n                top[2] = *b; /* move key to argv[1] */\n                top[3] = *c; /* move src to argv[2] */\n                vm->top += 4;\n                be_dofunc(vm, top, 3); /* call method \'setitem\' */\n                vm->top -= 4;\n                reg = vm->reg;\n            } else {\n                vm_error(vm, "type_error",\n                    "value \'%s\' does not support index assignment",\n                    be_vtype2str(a));\n            }\n            dispatch();\n        }\n        opcase(SETSUPER): {\n            bvalue *a = RA(), *b = RKB();\n            if (var_isclass(a) && var_isclass(b)) {\n                bclass *obj = var_toobj(a);\n                be_class_setsuper(obj, var_toobj(b));\n            } else {\n                vm_error(vm, "type_error",\n                    "value \'%s\' does not support set super",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CLOSE): {\n            be_upvals_close(vm, RA());\n            dispatch();\n        }\n        opcase(IMPORT): {\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int res = be_module_load(vm, name);\n                reg = vm->reg;\n                switch (res) {\n                case BE_OK: /* find the module */\n                    be_stackpop(vm, 1);\n                    *RA() = *vm->top;\n                    break;\n                case BE_EXCEPTION: /* pop the exception value and message */\n                    be_pop(vm, 2);\n                    be_throw(vm, BE_EXCEPTION);\n                    break;\n                default:\n                    vm_error(vm, "import_error", "module \'%s\' not found", str(name));\n                }\n            } else {\n                vm_error(vm, "type_error",\n                    "import \'%s\' does not support import",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CATCH): {\n            bvalue *base = RA(), *top = vm->top;\n            int i = 0, ecnt = IGET_RKB(ins), vcnt = IGET_RKC(ins);\n            while (i < ecnt && !be_vm_iseq(vm, top, base + i)) {\n                ++i;\n            }\n            if (!ecnt || i < ecnt) { /* exception catched */\n                base = RA(), top = vm->top;\n                for (i = 0; i < vcnt; ++i) {\n                    *base++ = *top++;\n                }\n                vm->ip += 1; /* skip next instruction */\n            }\n            dispatch();\n        }\n        opcase(RAISE): {\n            if (IGET_RA(ins) < 2) {  /* A==2 means no arguments are passed to RAISE, i.e. rethrow with current exception */\n                bvalue *top = vm->top;\n                top[0] = *RKB(); /* push the exception value to top */\n                if (IGET_RA(ins)) { /* has exception argument? */\n                    top[1] = *RKC(); /* push the exception argument to top + 1 */\n                } else {\n                    var_setnil(top + 1);\n                }\n                be_save_stacktrace(vm);\n            }\n            be_throw(vm, BE_EXCEPTION); /* throw / rethrow the exception */\n            dispatch();\n        }\n        opcase(EXBLK): {\n            if (!IGET_RA(ins)) {\n                be_except_block_setup(vm);\n                if (be_setjmp(vm->errjmp->b)) {\n                    be_except_block_resume(vm);\n                    goto newframe;\n                }\n                reg = vm->reg;\n            } else {\n                be_except_block_close(vm, IGET_Bx(ins));\n            }\n            dispatch();\n        }\n        opcase(CALL): {\n            bvalue *var = RA();  /* `var` is the register for the call followed by arguments */\n            int mode = 0, argc = IGET_RKB(ins);  /* B contains number of arguments pushed on stack */\n        recall: /* goto: instantiation class and call constructor */\n            switch (var_type(var)) {\n            case NOT_METHOD:\n                var[0] = var[1];\n                ++var, --argc, mode = 1;\n                goto recall;\n            case BE_CLASS:\n                if (be_class_newobj(vm, var_toobj(var), var, ++argc, mode)) {  /* instanciate object and find constructor */\n                    reg = vm->reg + mode;  /* constructor found */\n                    mode = 0;\n                    var = RA() + 1; /* to next register */\n                    goto recall; /* call constructor */\n                }\n                break;\n            case BE_INSTANCE: {\n                bvalue *v = var + argc++, temp;\n                /* load the \'()\' method to `temp\' */\n                obj_method(vm, var, str_literal(vm, "()"), &temp);\n                for (; v >= var; --v) v[1] = v[0];\n                *var = temp;\n                goto recall; /* call \'()\' method */\n            }\n            case BE_CLOSURE: {\n                // bvalue *v, *end;\n                // bproto *proto = var2cl(var)->proto;  /* get proto for closure */\n                // push_closure(vm, var, proto->nstack, mode);  /* prepare stack for closure */\n                // reg = vm->reg;  /* `reg` has changed, now new base register */\n                // v = reg + argc;  /* end of provided arguments */\n                // end = reg + proto->argc;  /* end of expected arguments */\n                // for (; v < end; ++v) {  /* set all not provided arguments to nil */\n                //     var_setnil(v);\n                // }\n                // if (proto->varg) {  /* there are vararg at the last argument, build the list */\n                //     /* code below uses mostly low-level calls for performance */\n                //     be_stack_require(vm, argc + 2);   /* make sure we don\'t overflow the stack */\n                //     bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the \'list\' instance */\n                //     vm->top = v;  /* move top of stack right after last argument */\n                //     be_newobject(vm, "list");  /* this creates 2 objects on stack: list instance, BE_LIST object */\n                //     blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */\n                //     v = reg + proto->argc - 1;  /* last argument */\n                //     for (; v < reg + argc; v++) {\n                //         be_list_push(vm, list, v); /* push all varargs into list */       \n                //     }\n                //     *(reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */\n                //     vm->top = top_save;  /* restore top of stack pointer */\n                // }\n                prep_closure(vm, var, argc, mode);\n                reg = vm->reg;  /* `reg` has changed, now new base register */\n                goto newframe;  /* continue execution of the closure */\n            }\n            case BE_NTVCLOS: {\n                bntvclos *f = var_toobj(var);\n                push_native(vm, var, argc, mode);\n                f->f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_NTVFUNC: {\n                bntvfunc f = var_tontvfunc(var);\n                push_native(vm, var, argc, mode);\n                f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_MODULE: {\n                bvalue attr;\n                var_setstr(&attr, str_literal(vm, "()"));\n                module_attribute(vm, var, &attr, var);  /* exception if not found */\n                goto recall; /* call \'()\' method */\n                break;\n            }\n            default:\n                call_error(vm, var);\n            }\n            reg = vm->reg;\n            dispatch();\n        }\n        opcase(RET): {\n            bcallframe *cf;\n            bvalue *ret;\n#if BE_USE_DEBUG_HOOK\n            be_callhook(vm, BE_HOOK_RET);\n#endif\n            cf = vm->cf;\n            ret = vm->cf->func;\n            /* copy return value */\n            if (IGET_RA(ins)) {\n                *ret = *RKB();\n            } else {\n                var_setnil(ret);\n            }\n            vm->reg = cf->reg;\n            vm->top = cf->top;\n            vm->ip = cf->ip;\n            be_stack_pop(&vm->callstack); /* pop don\'t delete */\n            if (cf->status & BASE_FRAME) { /* entrance function */\n                bstack *cs = &vm->callstack;\n                if (!be_stack_isempty(cs)) {\n                    vm->cf = be_stack_top(cs);\n                }\n                return;\n            }\n            vm->cf = be_stack_top(&vm->callstack);\n            goto newframe;\n        }\n    }\n}\n\nstatic void prep_closure(bvm *vm, bvalue *reg, int argc, int mode)\n{\n    bvalue *v, *end;\n    bproto *proto = var2cl(reg)->proto;\n    push_closure(vm, reg, proto->nstack, mode);\n    v = vm->reg + argc;\n    end = vm->reg + proto->argc;\n    for (; v <= end; ++v) {\n        var_setnil(v);\n    }\n    if (proto->varg) {  /* there are vararg at the last argument, build the list */\n        /* code below uses mostly low-level calls for performance */\n        be_stack_require(vm, argc + 2);   /* make sure we don\'t overflow the stack */\n        bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the \'list\' instance */\n        vm->top = v;  /* move top of stack right after last argument */\n        be_newobject(vm, "list");  /* this creates 2 objects on stack: list instance, BE_LIST object */\n        blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */\n        v = vm->reg + proto->argc - 1;  /* last argument */\n        for (; v < vm->reg + argc; v++) {\n            be_list_push(vm, list, v); /* push all varargs into list */       \n        }\n        *(vm->reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */\n        vm->top = top_save;  /* restore top of stack pointer */\n    }\n}\n\nstatic void do_closure(bvm *vm, bvalue *reg, int argc)\n{\n    // bvalue *v, *end;\n    // bproto *proto = var2cl(reg)->proto;\n    // push_closure(vm, reg, proto->nstack, 0);\n    // v = vm->reg + argc;\n    // end = vm->reg + proto->argc;\n    // for (; v <= end; ++v) {\n    //     var_setnil(v);\n    // }\n    prep_closure(vm, reg, argc, 0);\n    vm_exec(vm);\n}\n\nstatic void do_ntvclos(bvm *vm, bvalue *reg, int argc)\n{\n    bntvclos *f = var_toobj(reg);\n    push_native(vm, reg, argc, 0);\n    f->f(vm); /* call C primitive function */\n    ret_native(vm);\n}\n\nstatic void do_ntvfunc(bvm *vm, bvalue *reg, int argc)\n{\n    bntvfunc f = var_tontvfunc(reg);\n    push_native(vm, reg, argc, 0);\n    f(vm); /* call C primitive function */\n    ret_native(vm);\n}\n\nstatic void do_class(bvm *vm, bvalue *reg, int argc)\n{\n    if (be_class_newobj(vm, var_toobj(reg), reg, ++argc, 0)) {\n        be_incrtop(vm);\n        be_dofunc(vm, reg + 1, argc);\n        be_stackpop(vm, 1);\n    }\n}\n\nvoid be_dofunc(bvm *vm, bvalue *v, int argc)\n{\n    be_assert(vm->reg <= v && v < vm->stacktop);\n    be_assert(vm->stack <= vm->reg && vm->reg < vm->stacktop);\n    switch (var_type(v)) {\n    case BE_CLASS: do_class(vm, v, argc); break;\n    case BE_CLOSURE: do_closure(vm, v, argc); break;\n    case BE_NTVCLOS: do_ntvclos(vm, v, argc); break;\n    case BE_NTVFUNC: do_ntvfunc(vm, v, argc); break;\n    default: call_error(vm, v);\n    }\n}\n\nBERRY_API void be_set_obs_hook(bvm *vm, bobshook hook)\n{\n    (void)vm;       /* avoid comiler warning */\n    (void)hook;     /* avoid comiler warning */\n\n#if BE_USE_OBSERVABILITY_HOOK\n    vm->obshook = hook;\n#endif\n}\n']])